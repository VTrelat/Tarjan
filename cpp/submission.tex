\documentclass[sigplan,10pt,anonymous,review]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}

\let\Bbbk\relax
\usepackage{isabellelst}

\title{Verification in Isabelle/HOL of a Set-based Algorithm for Computing Strongly Connected Components}

\author{Stephan Merz}
\orcid{0000-0003-0974-1844}
\affiliation{
  \institution{University of Lorraine, CNRS, Inria, LORIA}
  \city{Nancy}
  \country{France}
}

\author{Vincent TrÃ©lat}
%\orcid{0000-0003-0974-1844}
\affiliation{
  \institution{University of Lorraine}
  \city{Nancy}
  \country{France}
}

\keywords{graph algorithm, strongly connected component, formal verification, interactive theorem proving}

\newcommand{\prog}[1]{\textit{#1}}
\renewcommand{\SS}{\mathcal{S}}

% ----------------------------------------------------------------------
\begin{document}
\begin{abstract}
  The efficient computation of strongly connected components in a directed graph is a fundamental algorithmic problem with applications in many fields of computer science. We report on the formal verification of a recent algorithm proposed by Bloemen in the proof assistant Isabelle/HOL. Our work is intended as a stepping stone towards a correctness proof of the parallel version of that algorithm, which has been implemented in the high-performance model checker LTSmin.
\end{abstract}

\maketitle

\section{Introduction}
\label{sec:introduction}
Directed graphs are widely used in many fields of computer science and mathematics.
The study of their properties is therefore an important topic because of their application in areas that may affect our lives.

They are also heavily used in critical domains that indirectly affect us, such as model checking.
Indeed, as model checking involves exhaustive exploration of graphs of states, it is important to have efficient -- and correct -- algorithms to perform different operations such as the computation of strongly connected components.

\section{Background}
\label{sec:background}

\subsection{Isabelle/HOL}
\label{sec:isabelle}

Isabelle~\cite{paulson:isabelle} is a logical framework in which different object logics can be encoded. Isabelle/HOL~\cite{nipkow_isabellehol_2002} is the instance of Isabelle for higher-order logic, which we use in our work and which we will refer to in the following simply as Isabelle. It provides an expressive formal language for representing formal mathematical theories as well as algorithms and their correctness proofs, and it comes with an extensive set of tools for defining \emph{locales} (algebraic structures parameterized by operators and assumptions), (mutually) \emph{recursive functions} etc.

Isabelle belongs to the LCF family of proof assistants whose soundness is ensured by a comparatively small trusted kernel that serves to certify proofs. From the user's point of view, Isabelle proofs are written in the Isar (``Intelligible Semi-Automated Reasoning'') language that is designed to make proofs readable and comprehensible for a mathematically inclined reader, with minimal overhead introduced by the formalism. Extensive automation is provided by built-in proof procedures based on rewriting and first-order reasoning, as well as the \emph{Sledgehammer}~\cite{blanchette:sledgehammer} add-on that selects potentially relevant lemmas from the context (including the standard proof library), calls external automatic proof backends such as SMT solvers as well as automatic proof tools for first-order and higher-order logic, and in case of success reconstructs their proofs in the trusted kernel.


\subsection{Graphs and strongly connected components}
\label{sec:graphs}

We represent finite directed graphs with nodes of type $\nu$ as an Isabelle locale that fixes a finite set of vertices and a successor function associating to each node its set of successor nodes.

\begin{small}
\begin{lstlisting}[language=isabelle]
locale graph =
  fixes   vertices :: 'v set
  and     successors :: 'v => 'v set
  assumes finite vertices  
  and     forall v sin vertices. successors v subseteq vertices
\end{lstlisting}
\end{small}

Reachability in graphs is defined inductively as follows.

\begin{small}
\begin{lstlisting}[language=isabelle]
inductive reachable where
  reachable-refl: reachable x x
| reachable-succ: [| y sin successors x; reachable y z |]
                  ==> reachable x z
\end{lstlisting}
\end{small}

Elementary lemmas, such as transitivity of the reachability relation, are easily proved by induction, followed by an application of Isabelle's automatic proof methods. For our later proofs, we also need the following variant of reachability between nodes avoiding a set $E$ of edges.

\begin{small}
\begin{lstlisting}[language=isabelle]
inductive reachable-avoiding where
  ra-refl: reachable-avoiding x x E
| ra-succ: [| y sin successors x; (x,y) notin E; 
              reachable-avoiding y z E |] 
           ==> reachable-avoiding x z E
\end{lstlisting}
\end{small}

Again, this relation is transitive, it implies reachability, is anti-monotonic in the set $E$, and reachability agrees with reachability avoiding the empty set of edges. More interestingly, we show the following lemma about adding an edge to the set $E$.

\begin{small}
\begin{lstlisting}[language=isabelle]
lemma ra-add-edge:
  assumes reachable-avoiding x y E
  shows   reachable-avoiding x y (E cup {(v,w)})
        \/ reachable-avoiding x v (E cup {(v,w)})
           /\ reachable-avoiding w y (E cup {(v,w)})
\end{lstlisting}
\end{small}

A partial SCC is a set $S$ of nodes all of which are reachable from each other. In particular, a cycle in a graph constitutes a partial SCC. A maximal SCC is a non-empty partial SCC none of whose supersets is a partial SCC. In the following, we write SCC to denote maximal SCCs.

\begin{small}
\begin{lstlisting}[language=isabelle]
definition is-subscc where
  is-subscc S == forall x sin S. forall y sin S. reachable x y

definition is-scc where
  is-scc S == S noteq {} /\ is-subscc S
              /\ (forall S'. S subseteq S' /\ is-subscc S'
                       --> S' = S)
\end{lstlisting}
\end{small}

Sledgehammer finds a one-line proof showing that two SCCs are either disjoint or identical:

\begin{small}
\begin{lstlisting}[language=isabelle]
lemma scc-partition:
  assumes is-scc S and is-scc S' and x sin S cap S'
  shows   S = S'
\end{lstlisting}
\end{small}


\section{Formalization of Bloemen's Algorithm in Isabelle/HOL}
\label{sec:formalization}

The data on which the algorithm operates is collected in an ``environment'' record with the following components:

\begin{small}
\begin{lstlisting}[language=isabelle]
record 'v env =
  root :: 'v
  SS :: 'v => 'v set
  visited :: 'v set
  explored :: 'v set
  sccs :: 'v set set
  stack :: 'v list
  cstack :: 'v list
  vsuccs :: 'v => 'v set
\end{lstlisting}
\end{small}

The \prog{root} component stores the node for which the algorithm was originally called.
The function $\SS$ maps every node $v$ to the set of nodes that have already been determined to be part of the same SCC as $v$. A core invariant of the algorithm will be that this mapping represents a partition of nodes into sets of equivalence classes: for all nodes $v$ and $w$, we maintain the relationship
\[
  v \in \SS~w\ \longleftrightarrow\ \SS~v = \SS~w.
\]
The sets \prog{visited} and \prog{explored} represent the sets of nodes that have already been seen, respectively fully explored, by the algorithm, and \prog{sccs} is the set of (maximal) SCCs that the algorithm has found so far. Variable \prog{stack} holds the roots of the (incomplete) SCCs in depth-first order, whereas \prog{cstack} represents the stack of calls of the main function \prog{dfs} of the algorithm. Finally, \prog{vsuccs} remembers the set of outgoing edges (represented by the successor nodes) of each node that have already been followed during the exploration. Note that the variables \prog{root} and \prog{cstack} are not actually used by the algorithm: they are ghost variables used in the correctness proof.

The algorithm will initially be called with an environment of the form $\prog{init-env}~v$ that holds $v$ as the root node, initializes $\SS$ by assigning the singleton $\{u\}$ to every node $u$, and has all other component initialized to the empty set or the empty list.

Environments are partially ordered according to the following relation.

\begin{small}
\begin{lstlisting}[language=isabelle]
definition sub-env where
sub-env e e' ==
    root e' = root e
  /\ visited e subseteq visited e'
  /\ explored e subseteq explored e'
  /\ (forall v. vsuccs e v subseteq vsuccs e' v)
  /\ (forall v. SS e v subseteq SS e' v)
  /\ (Union {SS e v | v. v sin set (stack e)})
     subseteq (Union {SS e' v | v. v sin set (stack e')})
\end{lstlisting}
\end{small}

We follow the definition of the algorithm in~\cite{bloemen:strong}, but represent it as a pair of mutually recursive functions \prog{dfs} and \prog{dfss} defined as follows.

\begin{small}
\begin{lstlisting}[language=isabelle]
function dfs  :: 'v => 'v env => 'v env
and      dfss :: 'v => 'v env => 'v env where
  dfs v e =
    let e1 = e(| visited := visited e cup {v},
                 stack := v # stack e,
                 cstack := v # cstack e |);
        e' = dfss v e1
    in  if v = hd (stack e')
        then e'(| sccs := sccs e' cup {SS e' v},
                  explored := explored e' cup SS e' v,
                  stack := tl (stack e'),
                  cstack := tl (cstack e') |)
        else e'(| cstack := tl (cstack e') |)
| dfss v e =
    let vs = successors v - vsuccs e v
    in  if vs = {} then e
        else let w = SOME x. x sin vs;
                 e' = (if w sin explored e then e
                       else if w notin visited e
                            then dfs w e
                            else unite w e);
                 e'' = e'(| vsuccs := lambda x. 
                              if x = v 
                              then vsuccs e' v cup {w}
                              else vsuccs e' x|)
             in dfss v e''
\end{lstlisting}
\end{small}

Function \prog{dfs} explores a node $v$ by adding it to the set of visited nodes, pushing it on both stacks, and then calling the function \prog{dfss}. If $v$ is still at the head of the stack, it is the root node of an SCC, and therefore $\SS~v$ is added to the set of maximal SCCs, all its nodes are marked as fully explored, and $v$ is popped from both stacks. Otherwise, $v$ is only popped from the call stack. The tail-recursive function \prog{dfss} iterates over all successors $w$ of node $v$. If $w$ has already been fully explored, there is nothing to do. If $w$ is unvisited, the function \prog{dfs} is called for $w$, otherwise the algorithm detected a loop back to a node that has already been visited and whose root node $r$ must therefore be on the stack. It unites the SCCs of all nodes contained in the prefix\footnote{Note that the top of the stack is at the head of the list.} of the stack starting at $r$, using the following auxiliary function.

\begin{small}
\begin{lstlisting}[language=isabelle]
definition unite :: 'v => 'v env => 'v env where
unite w e ==
  let pfx = takeWhile (lambda x. w notin SS e x) (stack e);
      sfx = dropWhile (lambda x. w notin SS e x) (stack e);
      cc = Union { SS e x | x . x sin set pfx cup {hd sfx} }
  in  e(| SS := lambda x. if x sin cc then cc else SS e x;
          stack := sfx |)
\end{lstlisting}
\end{small}

In words, \prog{unite} computes the prefix of the stack consisting of the roots of SCCs that do not contain $w$. Since $w$ must be represented by some node on the stack, the remaining suffix is non-empty, and $\SS~(\prog{hd}~\prog{sfx})$ contains $w$. A new connected component $\prog{cc}$ is computed by taking the union of the sets $\SS~x$ for all nodes $x$ in the prefix and the head of the suffix. The mapping $\SS$ is updated so that all nodes in $\prog{cc}$ are mapped to $\prog{cc}$, and the stack is shortened to the suffix of the previous stack, implicitly making the head of that suffix the root of the component $cc$.

Internally, Isabelle generates a single function \prog{dfs-dfss} whose argument type is the sum of the argument types for the individual functions, and defines the latter as projections of the combined function. Auto-generated theorems, such as computational induction, simultaneously handle both functions in order to enable mutual induction. A technical complication in the definition of the algorithm is that the functions \prog{dfs} and \prog{dfss} need not terminate when their pre-conditions are violated. We will come back to proving termination in Sect.~\ref{sec:termination}.


\section{Proof of Partial Correctness}
\label{sec:partial-correctness}

\subsection{Main invariant}
\label{sec:invariant}

We define well-formed environments to be those satisfying the following conditions, and we will prove this predicate to hold throughout the execution of the algorithm.

\begin{small}
\begin{lstlisting}[language=isabelle]
definition wf-env where
wf-env e ==
    (forall n sin visited e. reachable (root e) n)
  /\ distinct (stack e)
  /\ distinct (cstack e)
  /\ (forall n m. n prec m in stack e --> n prec m in cstack e)
  /\ (forall n m. n prec m in stack e --> reachable m n)
  /\ explored e subseteq visited e
  /\ set (cstack e) subseteq visited e
  /\ (forall n sin explored e. forall m. 
        reachable n m --> m sin explored e)
  /\ (forall n. vsuccs e n subseteq successors n cap visited e)
  /\ (forall n. n notin visited e --> vsuccs e n = {})
  /\ (forall n sin explored e. vsuccs e n = successors n)
  /\ (forall n sin visited e - set (cstack e). 
        vsuccs e n = successors n)
  /\ (forall n m. m sin SS e n <--> SS e n = SS e m)
  /\ (forall n. n notin visited e --> SS e n = {n})
  /\ (forall n sin set (stack e). forall m sin set (stack e).
        n noteq m --> SS e n cap SS e m = {})
  /\ Union {SS e n | n. n sin set (stack e)} 
     = visited e - explored e
  /\ (forall n in set (stack e). forall m in SS e n.
        m sin set (cstack e) --> m prec n in cstack e)
  /\ (forall n m. n prec m in stack e /\ n noteq m -->
        (forall u sin SS e n. ~ reachable-avoiding u m 
                                    (unvisited e n)))
  /\ (forall n. is-subscc (SS e n))
  /\ (forall S sin sccs e. is-scc S)
  /\ Union (sccs e) = explored e
\end{lstlisting}
\end{small}

In words, every visited node is reachable from the root node, the two stacks do not contain duplicate elements, and the stack is a subsequence of the call stack. Nodes on the stack are reachable from all stack nodes below them. All explored nodes, as well as all nodes on the call stack, are visited. All nodes reachable from fully explored nodes are themselves fully explored. The visited successors of a node are both successors and visited, and no outgoing edge of an unvisited node has been followed. All outgoing edges of fully explored nodes, as well as of visited nodes that are no longer on the call stack, have been followed. The mapping $\SS$ represents an equivalence relation, as discussed above, and $\SS~n$ is the singleton $\{n\}$ for an unvisited node $n$. The nodes on the stack are roots of (non-maximal) SCCs, hence their equivalence classes are disjoint. A node has been visited but not yet fully explored iff its root node is on the stack. Moreover, root nodes of SCCs are the oldest nodes in depth-first order. No node $u$ belonging to the SCC of a node $n$ on the stack can reach a node $m$ strictly below $n$ on the stack without going through some edge from some node in $n$'s equivalence class that has not yet been followed. In other words, the current SCCs are maximal with respect to the current knowledge of the algorithm. The set of not yet followed edges for nodes in the equivalence class of $n$ are defined as
%
\begin{small}
\begin{lstlisting}[language=isabelle]
definition unvisited where
unvisited e n ==
  {(a,b) | a b. a sin SS e n 
              /\ b sin successors a - vsuccs e a}
\end{lstlisting}
\end{small}
%
Finally, every equivalence class is a (not necessarily maximal) SCC, elements of \prog{sccs} are maximal SCCs, and their union is the set of explored nodes.

%% Not sure if we need this ...
We prove a number of simple consequences of this predicate. For example, $n \in \SS~n$ holds for every node~$n$. If node $w$ is reachable from a visited node $v$, but not through any edge that has not yet been followed, then $w$ must be visited. Also, edges towards fully explored nodes do not contribute to reachability of unexplored nodes avoiding certain edges:
%
\begin{small}
\begin{lstlisting}[language=isabelle]
lemma avoiding-explored:
assumes wf-env e and reachable-avoiding x y E
    and y notin explored e and w sin explored e
shows   reachable-avoiding x y (E cup {(v,w)})
\end{lstlisting}
\end{small}


\subsection{Pre- and post-conditions of functions \prog{dfs} and \prog{dfss}}
\label{sec:pre-post}

The proof of correctness relies on the fact that a call of \prog{dfs} for arguments that satisfy some hypotheses (the pre-conditions) terminates and satisfies some properties (the post-conditions). Because of the mutual recursion, we must define pre- and post-conditions for both \prog{dfs} and \prog{dfss}.

First, we define pre- and post-conditions for function \prog{dfs}.

\begin{small}
\begin{lstlisting}[language=isabelle]
definition pre-dfs where 
  pre-dfs v e ==
    wf-env e
  /\ v notin visited e
  /\ reachable (root e) v
  /\ (forall n sin set (stack e). reachable n v)
\end{lstlisting}
\end{small}

Function \prog{dfs} should be called for a well-formed environment and a node $v$ that has not yet been visited and that is reachable from the root node, as well as from all nodes in the stack.
% In fact, this is a consequence of wf-env e and v \notin visited e, and can be dropped.
% No outgoing edges from node $v$ have yet been followed.

\begin{small}
\begin{lstlisting}[language=isabelle]
definition post-dfs where 
  post-dfs v e e' ==
    wf-env e'
  /\ sub-env e e'
  /\ v sin visited e'
  /\ vsuccs e' v = successors v
  /\ (forall w sin visited e. vsuccs e' w = vsuccs e w)
  /\ (exists ns. stack e = ns @ (stack e'))
  /\ cstack e' = cstack e
  /\ ((v sin explored e' /\ stack e' = stack e 
      /\ (forall n sin set (stack e'). SS e' n = SS e n)) 
    \/ (stack e' noteq [] /\ v sin SS e' (hd (stack e')) 
      /\ (forall n sin set (tl (stack e')). SS e' n = SS e n)))
\end{lstlisting}
\end{small}

Function \prog{dfs} maintains the invariant \prog{wf-env} and returns an environment $e'$ that extends the input environment $e$. Node $v$ has been visited and all its outgoing edges have been followed. Because the algorithm works in depth-first fashion, no new outgoing edges of nodes that had already been visited in the input environment have been followed, and the stack of $e'$ is a suffix of the stack of $e$.
% Again, this follows from the pre-condition and the suffix property.
% such that $v$ is still reachable from all nodes on the stack. 
The stack may have been shortened because SCCs represented at the top of the stack may have been merged. The call stack is reestablished as it was in $e$. There are two possible outcomes of the algorithm:
\begin{itemize}
\item Either $v$ has been fully explored, in which case the stacks of $e$ and $e'$ are the same, and the partial SCCs of all nodes represented on the stack are unchanged. This corresponds to the case where $v$ is the root node of its (maximal) SCC.
\item Alternatively, the stack of $e'$ must be non-empty and $v$ must be a member of the partial SCC of the node at the top of the stack. The SCCs represented by the stack elements other than the top are unchanged. This corresponds to the case where $v$ is not the root node of its SCC, and some SCCs at the top of the stack may have been merged.
\end{itemize}

We then define pre- and post-conditions for function \prog{dfss}.

\begin{small}
\begin{lstlisting}[language=isabelle]
definition pre-dfss where 
  pre-dfss v e ==
    wf-env e 
  /\ v sin visited e
  /\ stack e noteq []
  /\ v sin SS e (hd (stack e))
  /\ (forall w sin vsuccs e v.
      w sin explored e cup SS e (hd (stack e)))
  /\ (forall n sin set (stack e). reachable n v)
  /\ (exists ns. cstack e = v # ns)
\end{lstlisting}
\end{small}

The pre-condition of function \prog{dfss} corresponds to the invariant of the loop over all outgoing edges from node~$v$. The environment is well-formed, node~$v$ has been visited and is represented by the top of the (non-empty) stack, it is reachable from all nodes on the stack, and it is the top node on the call stack. All outgoing edges of node $v$ that have already been followed either lead to completely explored nodes or to nodes that are part of the same SCC as~$v$.

Function \prog{dfss} establishes the following post-condition:

\begin{small}
\begin{lstlisting}[language=isabelle]
definition post-dfss where 
  post-dfss v e e' == 
     wf-env e'
   /\ sub-env e e'
   /\ vsuccs e' v = successors v
   /\ (forall w sin visited e - {v}. vsuccs e' w = vsuccs e w)
   /\ (forall w sin successors v.
        w sin explored e' cup SS e' (hd (stack e')))
   /\ (forall n sin set (stack e'). reachable n v)
   /\ (stack e' noteq [])
   /\ (exists ns. stack e = ns @ (stack e'))
   /\ cstack e' = cstack e
   /\ v sin SS e' (hd (stack e'))
   /\ (forall n sin set (tl (stack e')). SS e' n = SS e n)
   /\ (hd (stack e') = v -->
        (forall n sin set (tl (stack e')). ~ reachable v n))
\end{lstlisting}
\end{small}

In the same way as function \prog{dfs}, function \prog{dfss} ensures that the resulting environment $e'$ is well-formed and extends the input environment $e$, that all outgoing edges of $v$, and no outgoing edges of previously visited nodes other than $v$ have been followed. Again, the new stack is a suffix of the old one, and the call stack is restored. In case node $v$ is still on the stack (and therefore is the root node of its SCC), no stack node below $v$ can be reached from $v$. This condition is important for ensuring that the computed SCC is maximal.


\subsection{Lemmas establishing the pre-conditions}
\label{sec:pre-pre}

First, it is easy to see (and Isabelle proves automatically) that the initial environment satisfies the pre-condition of function \prog{dfs}.

\begin{small}
\begin{lstlisting}[language=isabelle]
lemma init-env-pre-dfs: pre-dfs v (init-env v)
\end{lstlisting}
\end{small}

Given that the two functions \prog{dfs} and \prog{dfss} mutually call each other, we need to establish the pre-condition of the called function, assuming the pre-condition of the calling function.

For example, the following lemma asserts that the pre-condition of \prog{dfss} holds at the call from the body of \prog{dfs}. Although some of the conditions of the invariant for the augmented environment require a few lines of proof, the overall proof is straightforward.

\begin{small}
\begin{lstlisting}[language=isabelle]
lemma pre-dfs-pre-dfss:
  assumes pre-dfs v e
  shows   pre-dfss v (e(| visited := visited e cup {v},
                         stack := v # stack e,
                         cstack := v # cstack e |))
\end{lstlisting}
\end{small}

The following lemma asserts the pre-condition of the recursive call to \prog{dfs} from \prog{dfss} for a successor that has not been visited yet. Its proof is entirely automatic, helped by the fact that the environment of the call to \prog{dfs} is unchanged.

\begin{small}
\begin{lstlisting}[language=isabelle]
lemma pre-dfss-pre-dfs:
  assumes pre-dfss v e and w sin successors v - visited e
  shows   pre-dfs w e
\end{lstlisting}
\end{small}

Finally, we need to show the pre-condition of \prog{dfss} at the call of \prog{dfss} at the end of the function body, i.e.\ the preservation of the loop invariant. We state three separate lemmas according to the branch of the conditional in the computation of the intermediate environment $e'$ in the body of \prog{dfss}. As an example, we show the statement of the lemma corresponding to the third branch.

\begin{small}
\begin{lstlisting}[language=isabelle]
lemma pre-dfss-unite-pre-dfss:
  fixes e v w
  defines e' = unite w e
  defines e'' = e'(| vsuccs := (lambda x. if x = v 
                                then vsuccs e' v cup {w}
                                else vsuccs e' v) |)
  assumes pre-dfss v e
    and   w sin successors v - vsuccs e
    and   w sin visited e
    and   w notin explored e
  shows   pre-dfss v e''
\end{lstlisting}
\end{small}

Some steps in the proof of this lemma require a substantial number of interactions. We started by proving several auxiliary lemmas about function \prog{unite}, including the fact that the intermediate environment $e'$ is well-formed. Then, we have to show that this invariant also holds for $e''$. For example, given two nodes $x \neq y$ such that $x$ precedes $y$ in the stack of $e''$ (which is the same as the stack of $e'$) and a node $u \in \SS~e''~x = \SS~e'~x$, we must show that $y$ can be reachable from $u$ only by following some edge in $\prog{unvisited}~e''~x$. Therefore, assume that $y$ is reachable from $u$ avoiding all edges in $\prog{unvisited}~e''~x$. The proof proceeds by a case analysis depending on whether $x$ is the head of $\prog{stack}~e'$ or not.

In case it is, the definitions of \prog{unvisited} and of $e''$ imply that either $\prog{unvisited}~e'~x = \prog{unvisited}~e''~x$ or $\prog{unvisited}~e'~x = \prog{unvisited}~e''~x \cup \{(v,w)\}$. In the first case, we can conclude directly by appealing to the well-formedness of $e'$. In the second case, lemma \prog{ra-add-edge} tells us that either $y$ is reachable from $u$ avoiding edges in $\prog{unvisited}~e'~x$ or that $y$ is reachable from $w$ avoiding the same set of edges. In the first case, we again conclude appealing to the well-formedness of $e'$. In the second case, we know that $w \in \SS~e'~x$ (since $x$ is the head of $\prog{stack}~e'$) and therefore find another contradiction to the well-formedness of $e'$.

In case $x$ is not the head of $\prog{stack}~e'$, both nodes $x$ and $y$ must already be elements of $\prog{stack}~e$, with $x$ still preceding $y$. Also, the pre-condition $\prog{pre-dfss}~v~e$ implies that $v$ is a member of the partial SCC represented by the head of the stack, and using the well-formedness of $e$ it follows that $v \notin \SS~e'~x$ and therefore $\prog{unvisited}~e''~x = \prog{unvisited}~e'~x = \prog{unvisited}~e~x$. We can now conclude by appealing to the well-formedness of the environment $e$.


\subsection{Pre-conditions imply post-conditions}
\label{sec:pre-post}

The following theorem is central for the proof of partial correctness: it shows that the functions \prog{dfs} and \prog{dfss} establish their respective post-conditions, assuming that the pre-conditions hold for the input parameters. Because we have not proved termination of the functions, we need an additional hypothesis for each statement that, intuitively, asserts that the corresponding function will terminate for its input parameters.

\begin{small}
\begin{lstlisting}[language=isabelle]
lemma pre-post:
  [| dfs-dfss-dom (Inl (v,e)); pre-dfs v e |] 
     ==> post-dfs v e (dfs v e)
  [| dfs-dfss-dom (Inr (v,e)); pre-dfss v e |]
     ==> post-dfss v e (dfss v e)
\end{lstlisting}
\end{small}

Since the two functions are mutually recursive, the two statements must be proved by simultaneous computational induction, based on the corresponding proof rule generated by Isabelle. The proofs of these implications again involve a certain number of steps requiring detailed interaction.

As an example, in the first branch of the conditional in the body of function \prog{dfs} we need to prove that all nodes~$y$ reachable from an explored node $x$ are themselves explored. The interesting case occurs when $x \in \SS~e'~v$, where $e'$ denotes the environment computed by the call to \prog{dfss}. Because $\SS~e'~v$ is a partial SCC, node~$x$ is reachable from node~$v$. We first show that $y \in \prog{visited}~e'$. Otherwise, given that $x \in \prog{visited}~e'$, by induction we obtain nodes $n \in \prog{visited}~e'$ and $m \in \prog{successors}~n - \prog{vsuccs}~e'~n$ (i.e., $m$ is an unvisited successor of~$n$) such that $n$ is reachable from~$x$ and $y$ is reachable from~$m$. But then, we have $n \notin \prog{explored}~e'$ since all successors of explored nodes have been visited, hence there must be a node $n' \in \prog{set}~(\prog{stack}~e')$ such that $n \in \SS~e'~n'$. Using the last conjunct of the post-condition \prog{post-dfss}, it follows that $n' = v$, for otherwise $v$ could reach a node deeper in the stack. But then, we have $n \in \SS~e'~v \subseteq \prog{explored}~e'$, and according to another conjunct of the invariant that we already proved earlier, we must have $\prog{successors}~n = \prog{vsuccs}~e'~n$, reaching a contradiction.

We now prove $y \in \prog{explored}~e''$, where $e''$ denotes the environment resulting from the call to \prog{dfs}. If $y \in \prog{explored}~e'$, this is clearly true. Otherwise, we obtain some node $n \in \prog{set}~(\prog{stack}~e')$ such that $y \in \SS~e'~n$. If $n=v$, the assertion follows by the definition of $e''$. Otherwise, $n$ is a stack node below $v$ that is reachable from~$v$ via nodes~$x$ and~$y$, contradicting the last conjunct of the post-condition \prog{post-dfss}.

From the lemmas proved so far, we can infer the partial correctness of the function \prog{dfs} when called with the initial environment.

\begin{small}
\begin{lstlisting}[language=isabelle]
theorem partial-correctness:
  assumes dfs-dfss-dom (Inl (v, init-env v)
  shows   sccs (dfs v (init-env v)) = 
          {S . is-scc S /\ (forall n sin S. reachable v n)}
\end{lstlisting}
\end{small}

In words, assuming that function \prog{dfs} terminates for the input parameters, it computes the set of the maximal SCCs in the sub-graph reachable from node~$v$. In particular, if $v$ is a root node of the graph, the maximal SCCs of the graph will be computed.



\section{Proof of Termination}
\label{sec:termination}


\section{Conclusion}
\label{sec:conclusion}


\bibliography{bib}
\bibliographystyle{abbrv}

\end{document}
