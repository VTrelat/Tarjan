\documentclass[a4 paper, 12pt]{article}
\usepackage{amsmath, amsthm, amsfonts, amssymb, mathrsfs}
\usepackage{tikzit}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage[ruled,vlined, linesnumbered]{algorithm2e}

\input{style.tikzstyles}

% editorial comments in the text or in marginal notes
% 1st argument: initials of the person making the comment,
% 2nd argument: comment to insert
\long\def\ednote#1#2{\par\noindent\framebox{\begin{minipage}{0.99\linewidth}\linespread{.7}\footnotesize #1: #2\end{minipage}}\par}
\newcommand{\edmargin}[2]{\marginpar{\raggedright\linespread{.7}\tiny #1: #2}}

%__________________________________________
\newcommand{\ldb}{\mathopen{\ooalign{\makebox[.4em][l]{$\lbrack$}\cr\makebox[.4em][r]{$\lbrack$}\cr}}}                                                       
\newcommand{\rdb}{\mathclose{\ooalign{\makebox[.4em][l]{$\rbrack$}\cr\makebox[.4em][r]{$\rbrack$}\cr}}}

%__________________________________________

\hypersetup{
    colorlinks=true,
    linktoc=false,
    linkcolor=blue,
    citecolor=blue
}

%__________________________________________
% Colors definition
\definecolor{isa_red}{RGB}{255, 58, 71}
\definecolor{isa_blue}{RGB}{0, 103, 158}
\definecolor{isa_green}{RGB}{0, 157, 97}
\definecolor{isa_dark_green}{RGB}{0,131, 0}
\definecolor{isa_purple}{RGB}{174, 5, 238}
\definecolor{isa_dark_blue}{RGB}{26, 0, 253}

% Isabelle keywords
\newcommand{\stackprec}[3]{\texttt{#1}~\preceq~\texttt{#2}~\text{in}~\texttt{#3}}
\newcommand{\apply}{{\color{isa_red}{apply}}}
\newcommand{\done}{{\color{isa_red}{done}}}
\newcommand{\datatype}{{\color{isa_blue}{datatype}}}
\newcommand{\inductive}{{\color{isa_blue}{inductive}}}
\newcommand{\abbreviation}{{\color{isa_blue}{abbreviation}}}
\newcommand{\thm}{{\color{isa_blue}{theorem}}}
\newcommand{\lm}{{\color{isa_blue}{lemma}}}
\newcommand{\fun}{{\color{isa_blue}{fun}}}
\renewcommand{\locale}{{\color{isa_blue}{locale}}}
\newcommand{\where}{{\color{isa_green}{where}}}
\renewcommand{\and}{{\color{isa_green}{and}}}
\newcommand{\fixes}{{\color{isa_green}{fixes}}}
\newcommand{\assumes}{{\color{isa_green}{assumes}}}
\newcommand{\shows}{{\color{isa_green}{shows}}}
\newcommand{\generic}[1]{{\color{isa_purple}{\textquotesingle#1}}}
\newcommand{\isa}[1]{\small\texttt{\\\noindent#1}}
\newcommand{\blue}[1]{{\color{isa_dark_blue}{#1}}}
\newcommand{\bblue}[1]{{\color{isa_blue}{#1}}}
\newcommand{\green}[1]{{\color{isa_dark_green}{#1}}}
\newcommand{\env}[1]{$(\!|$#1$|\!)$}

\theoremstyle{definition}
\newtheorem{isabelle}{Isabelle}

\lstdefinelanguage{isabelle}{%
    keywords=[1]{type_synonym,datatype,fun,abbreviation,definition,proof,lemma,theorem,corollary},
    keywordstyle=[1]\bfseries\color{isarblue},
    keywords=[2]{where,assumes,shows,and},
    keywordstyle=[2]\bfseries\color{isargreen},
    keywords=[3]{if,then,else,case,of,SOME,let,in,O},
    keywordstyle=[3]\color{isarblue},
}
\lstset{%
  language=isabelle,
  escapeinside={&}{&},
  columns=fixed,
  extendedchars,
  basewidth={0.5em,0.45em},
  basicstyle=\ttfamily,
  mathescape,
}


%__________________________________________

% sm: better: \def\NN{\ensuremath{\mathcal{N}}} etc.
\def\NN{$\mathcal{N}~$}
\def\GG{$\mathcal{G}~$}
\def\VV{$\mathcal{V}~$}
\def\EE{$\mathcal{E}~$}

\renewcommand\qedsymbol{$\blacksquare$}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{corollary}{Corollary}[lemma]
\newtheorem{remark}{Remark}

%__________________________________________

% Node styles
\tikzstyle{white node}=[fill=none, draw=black, shape=circle, tikzit fill=white, tikzit draw=black]
\tikzstyle{red node}=[fill={rgb,255: red,232; green,118; blue,188}, draw=black, shape=circle, tikzit fill={rgb,255: red,232; green,118; blue,188}, tikzit draw=black]
\tikzstyle{blue node}=[fill={rgb,255: red,179; green,191; blue,255}, draw=black, shape=circle, tikzit fill={rgb,255: red,179; green,191; blue,255}, tikzit draw=black]
\tikzstyle{green node}=[fill={rgb,255: red,201; green,255; blue,189}, draw=black, shape=circle, tikzit fill={rgb,255: red,201; green,255; blue,189}, tikzit draw=black]

\tikzstyle{arrow}=[>]
\tikzstyle{new style 0}=[fill=none, draw=red, shape=circle, tikzit fill=none]
\tikzstyle{arrow}=[<--]
\tikzstyle{new edge style 2}=[- - -]

% Edge styles
\tikzstyle{right arrow}=[->]
\tikzstyle{right red arrow}=[->, draw=red, tikzit draw=red]
\tikzstyle{left arrow}=[<-]
\tikzstyle{left red arrow}=[<-, draw=red, tikzit draw=red]
\tikzstyle{right dashed arrow}=[->, dashed=1, dash pattern=on 1mm off 1mm, draw=red]
\tikzstyle{left dashed arrow}=[<-, dashed=1, dash pattern=on 1mm off 1mm, draw=red]
\tikzstyle{blue fill}=[-, fill={rgb,255: red,179; green,191; blue,255}, draw=none, tikzit draw=none, tikzit fill={rgb,255: red,213; green,207; blue,255}]
\tikzstyle{green fill}=[-, fill={rgb,255: red,201; green,255; blue,189}, draw=none, tikzit draw=none, tikzit fill={rgb,255: red,213; green,255; blue,208}]
\tikzstyle{red fill}=[-, fill={rgb,255: red,232; green,118; blue,188}, draw=none, tikzit draw=none, tikzit fill={rgb,255: red,232; green,118; blue,118}]

%-----------------------------------------------------------------

\begin{document}
\newgeometry{margin=2cm}
\begin{titlepage}
    \begin{figure}[!h]
        \centering
        \includegraphics[height = .1\textwidth]{img/logoartem.png}
        \hspace{1cm}
        \includegraphics[height = .1\textwidth]{img/logoloria.jpg}
        \hspace{1cm}
        \includegraphics[height = .1\textwidth]{img/logoUL.png}
    \end{figure}
    \vspace{3cm}

    \begin{center}
%        \huge{Strongly connected components algorithms : parallelization and proofs}
%        \huge{Formal methods and assisted proofs: application to strongly connected components algorithms}
        \huge{Formal verification of an algorithm for computing strongly connected components}
    \end{center}
    \vspace{1cm}
    \begin{center}
        \large{Département Informatique --- Parcours Recherche \\ Tuteur : Stephan Merz}
    \end{center}
    \vspace{1 cm}
    \begin{center}
        Vincent TRÉLAT
    \end{center}
    \vspace{2 cm}
    \begin{center}
        \textit{\today}
    \end{center}
    \vspace{2 cm}
    \begin{center}
        ***
    \end{center}
    
\end{titlepage}
\restoregeometry
\pagebreak

\pagebreak

\tableofcontents
\pagebreak

\section{Introduction}
\subsection{Academic context}
This research work was carried out as part of my curriculum at the French \href{https://mines-nancy.univ-lorraine.fr}{École des Mines de Nancy}. All documents such as codes or source papers are available on a \href{https://github.com/VTrelat/Tarjan}{GitHub repository}.

\subsection{Formal methods}
Formal methods are a field of computer science related to mathematical logic and reasoning. The whole purpose of the discipline is to ensure by a logical proof that a given algorithm is not only correct on its domain of definition, but also to find -- or define -- that domain. Formal methods find applications in a variety of fields, both concrete, such as the railway industry or self-driving cars, and abstract, such as computational architecture.
\BlankLine
Although a formal proof lies first on paper, the real formalisation starts when proofs are mechanised in a proof assistant.

\ednote{sm}{%
  First, a stylistic remark: do not end lines in a \LaTeX\ document using \texttt{\textbackslash\textbackslash} (except in \texttt{tabular} environments or similar). Use a blank line to start a new paragraph: the style will define the appearance of a paragraph break.

  More importantly, formal methods should not be equated with theorem proving. They are really about giving precise, mathematical definitions to computer science concepts. Although the purpose of giving such definitions is to enable formal verification, many techniques besides theorem proving, such as model-based testing, run-time monitoring, model checking etc.\ are used.
}

\subsection{Isabelle (HOL)}
\begin{quote}
    Isabelle is a generic proof assistant. It allows mathematical formulas to be expressed in a formal language and provides tools for proving those formulas in a logical calculus.
\end{quote}
\begin{flushright}
    \href{https://isabelle.in.tum.de/}{isabelle.in.tum.de}
\end{flushright}
Isabelle is a really powerful proof assistant coming with a higher order logic (HOL) proving environment. Isabelle proofs are written in the Isar (``intelligible semi-automated reasoning'') language that is designed to make proofs readable and comprehensible for a mathematically inclined reader, with minimal overhead introduced by the formalism. In fact, ``assistant'' refers to the fact that the machine checks the proof provided by the user, in contrast to automatic theorem proving where the machine finds the proof itself. The tools for automation are intended to help the user write the proof at a conveniently high level, without needing to work at the level of a logical calculus, for example.

\ednote{sm}{The introduction should also give an (informal) overview of what this report is about. Alternatively, split it into a section on the context of the work and one that introduces the subject. Avoid jumping directly into formal definitions without an introduction for the mere mortal.}

\pagebreak

\ednote{sm}{Again, the question whether or not to break pages at sections is decided by the \LaTeX{} style. I would not impose a page break here.}

\section{Formalisation}
\subsection{Strongly connected components}
\subsubsection{Directed graphs}\label{sec:directedgraphs}

\ednote{sm}{The first definition should introduce directed graphs. In particular, it is not formally clear what ``\VV'', ``\GG'', and ``reachability'' refer to in the following definition.

Side note: Your macros \VV, \GG, \EE introduce trailing blank space, which they should not. (Also, they do not work within math environments, which is mildly annoying.)
You may want to use the xspace style for intelligently appending a space after a macro.}

\begin{definition}[Reachability]
    For two vertices $x$ and $y$ of \VV, the reachability relation is noted ``$\Rightarrow^*$'' such that $x \Rightarrow^* y$ iff $x$ can reach $y$ in \GG.
\end{definition}

\begin{remark}
    The relation $\Rightarrow^*$ is in fact the transitive closure of the binary relation $\Rightarrow$ defining edges in a graph.
\end{remark}

\begin{definition}[SCC]
    Let \GG = (\VV, \EE) be a directed graph.
$\mathcal{C} \subseteq \mathcal{V}$ is a strongly connected component (SCC) of \GG if:
\begin{equation*}
    \forall x, y \in \mathcal{C}, (x \Rightarrow^* y) \wedge (y \Rightarrow^* x)
\end{equation*}
\textit{i.e.} there is a path between every $x$ and $y$ in $\mathcal{C}$.
\BlankLine
$\mathcal{C}$ is maximal, or $\mathcal{C}$ is a maximal SCC of \GG if there is no other SCC containing $\mathcal{C}$, \textit{i.e.} if:
\begin{equation*}
    \forall \mathcal{X}, (\mathcal{C} \subseteq \mathcal{X}) \wedge (\forall x, y \in \mathcal{X}, (x \Rightarrow^* y) \wedge (y \Rightarrow^* x)) \Longrightarrow \mathcal{C} = \mathcal{X}
\end{equation*}
\end{definition}

\begin{definition}(Strong connectedness)
Let \GG = (\VV, \EE) be a directed graph. \GG is strongly connected if \VV is a SCC.
\end{definition}

\subsubsection{Examples}
\begin{figure}[!h]
    \centering
    \begin{subfigure}[t]{.49\textwidth}
        \ctikzfig{example2}
        \subcaption{Strongly connected graph}
    \end{subfigure}
    \begin{subfigure}[t]{.49\textwidth}
        \ctikzfig{example3}
        \subcaption{Not strongly connected graph}
    \end{subfigure}
    \caption{Basic example of what is a small SCC}
\end{figure}
\begin{figure}[!h]
    \ctikzfig{exampleSCC}
    \caption{Example of a graph where each colored set of node is a -- maximal -- SCC\label{fig:exampleSCC}}
\end{figure}

\begin{figure}[!h]
    \ctikzfig{exampleSCCreduced}
    \caption{Reduced visualization of the graph represented in figure \ref{fig:exampleSCC}}
\end{figure}

\ednote{sm}{This section should contain some text in order to explain the figures, beyond the captions. Also, Fig.~1 is more about connected graphs than SCCs.}

\pagebreak

\section{A sequential set-based algorithm}
\subsection{Formalisation}
\begin{definition}[SCC mapping]
    In the following algorithm, the SCCs are progressively tracked in a collection of disjoint sets through a map $\mathcal{S} : \mathcal{V} \longrightarrow \mathcal{P}(\mathcal{V})$, where $\mathcal{P}(\mathcal{V})$ is the powerset of \VV, s.t. the following invariant is maintained:
    \begin{equation}\label{invariant:Sdisjoint}
        \forall v, w \in \mathcal{V}, w\in \mathcal{S}(v) \Longleftrightarrow \mathcal{S}(v) = \mathcal{S}(w)
    \end{equation}
\end{definition}

\begin{remark}
    In the following, the same notation $\mathcal{S}$ will be used to denote both the function defined above and the induced equivalence relation\footnote{For the relation $(x, y) \mapsto x \Rightarrow^* y ~\land~ y \Rightarrow^* x $} since $\mathcal{S}$ associates to each node its class of equivalence.
\end{remark}

\ednote{sm}{I don't quite understand this remark: $\mathcal{S}$ approximates mutual reachability, but doesn't capture it initially. Shouldn't the equivalence relation rather be $x \in \mathcal{S}(y) \land y \in \mathcal{S}(x)$?}

\begin{remark}
    In particular, $\forall v \in \mathcal{V}, v \in \mathcal{S}(v)$.
\end{remark}

\begin{definition}[SCC union]
    Let \textsc{Unite} be the function taking as parameters a map $\mathcal{S}$ as defined previously and two vertices $u$ and $v$ of $\mathcal{V}$ such that $\textsc{Unite}(\mathcal{S}, u, v)$ merges the two mapped sets $\mathcal{S}(u)$ and $\mathcal{S}(v)$ and maintains the invariant (\ref{invariant:Sdisjoint}) by updating $\mathcal{S}$.
\end{definition}
Let us give an example:\\
Let $\mathcal{V} = \{u,v,w\}$ such that there is the following mapping: $\mathcal{S}(u) = \{u\}$ and $\mathcal{S}(v) = \mathcal{S}(w) = \{v,w\}$.\\
Then, $\textsc{Unite}(\mathcal{S}, u, v) = \mathcal{S}(u) = \mathcal{S}(v) = \mathcal{S}(w) = \{u,v,w\}$.

\begin{definition}[Successors set for a node]
    Let $\mathcal{G} = (\mathcal{V}, \mathcal{E})$ and $v \in \mathcal{V}$. The set of successors of $v$ in \GG is \textsc{Post}($v$) such that:
    \begin{equation*}
        \forall w\in \textsc{Post}(v), (v,w)\in \mathcal{E}
    \end{equation*}
\end{definition}

\ednote{sm}{This definition is really about graphs and would fit better in section 2. Also, what you really want is $\textsc{Post}(v) = \{w : (v,w) \in \mathcal{E}\}$. The definition only provides an inclusion, for example $\textsc{Post}(v) = \emptyset$ satisfies it.}
  

\subsection{The algorithm}
See \cite{articleSCC} for the original paper.\\
\begin{algorithm}[H]\label{alg:seqsetbased}
    \SetAlgoLined
    \KwData{A graph \GG = (\VV, \EE), a starting node $v_0$\;}
    \KwResult{A partition \texttt{SCCs} of \VV where each element of \texttt{SCCs} is a maximal set of strongly connected components of \GG\;}
    Initialize an empty set \texttt{EXPLORED}\;
    Initialize an empty set \texttt{VISITED}\;
    Initialize an empty stack \texttt{R}\;
    setBased($v_0$)\;
    \SetKwProg{Function}{function}{}{}
    \Function{setBased: $v \in \mathcal{V} \rightarrow \texttt{None}$}{
        $\texttt{VISITED} := \texttt{VISITED} \cup \{v\}$\;
        \texttt{R.push($v$)}\;
        \ForEach{$w\in \texttt{POST(v)}$}{
            \If{$w\in \texttt{EXPLORED}$}{
                continue\;
            }
            \ElseIf{$w \notin \texttt{VISITED}$}{
                setBased($w$)\;
            }
            \Else{
                \While{$\mathcal{S}(v) \neq \mathcal{S}(w)$}{
                    $r := \texttt{R.pop()}$\;
                    $\texttt{UNITE}(\mathcal{S}, r, \texttt{R.top()})$\;
                }
            }
        }
        \If{$v = \texttt{R.top()}$}{
            \textbf{report SCC} $\mathcal{S}(v)$\;
            $\texttt{EXPLORED} := \texttt{EXPLORED} \cup \mathcal{S}(v)$\;
            \texttt{R.pop()}\;
        }
    }
    
    \caption{Sequential set-based SCC algorithm}
\end{algorithm}
\ednote{sm}{%
  Give some more context than just the reference for the algorithm.
  The algorithm should also explain how $\mathcal{S}$ is initialized.
  And the result is really such that each element of \texttt{SCCs} is a (maximal) strongly connected component, not a set of components, and it is the set of SCCs in the subgraph of \GG reachable from $v_0$.
}

\pagebreak

\subsection{Informal proof}
Note that this proof is said informal only because it is not checked by a mechanized proof assistant. Both logical and mathematical arguments developed below are absolutely relevant.

\begin{lemma}(First invariant)\label{lemma:disjointness}
    \begin{equation*}
        \forall x, y \in \texttt{R}, x\neq y \implies \mathcal{S}(x) \cap \mathcal{S}(y) = \varnothing
    \end{equation*}
    Note the misuse of the set notation $x, y \in \texttt{R}$ which just means that $x$ and $y$ are in the stack \texttt{R}.
\end{lemma}

\begin{proof}
    Let $x, y \in \texttt{R}$, $x \neq y$. We can assume w.l.o.g that $\stackprec{y}{x}{R}$.
    If $y \notin \mathcal{S}(x)$, then $\mathcal{S}(x)$ is disjoint from $\mathcal{S}(y)$.
    \BlankLine
    Otherwise, let us assume that $y \in \mathcal{S}(x)$, \textit{i.e.} $\mathcal{S}(x) = \mathcal{S}(y)$. Then, the \textit{while}\footnote{See \nameref{alg:seqsetbased}} loop will unstack all nodes of \texttt{R} until the successor of $x$ in \texttt{R} is reached and add them with \textsc{Unite} to $\mathcal{S}(x)$, so that the only representative of $\mathcal{S}(x)$ on \texttt{R} is $x$.
\end{proof}

\ednote{sm}{I do not find this proof convincing. The \texttt{while} loop is only executed at a certain point during the algorithm, and its condition is for two sets $\mathcal{S}$ to be different, not equal, as in the condition in the proof?}

\begin{remark}\label{rem:rootSCC}
    It is worth noting that the representative of a partial — with respect to the final result — SCC is the earliest node of this SCC to be visited regarding the graph traversal. This ensures that a representative on the stack is in fact the root of its SCC.
\end{remark}

\begin{lemma}
    \begin{equation*}
        \biguplus_{r \in \texttt{R}} \mathcal{S}(r) = \textsc{Live} := \textsc{Visited} \setminus \textsc{Explored}
    \end{equation*}
\end{lemma}

\begin{proof}
    The disjointness of all on-stack partial SCCs is given by lemma \ref{lemma:disjointness}. Nodes from $\textsc{Visited} \setminus \textsc{Explored}$ are in \texttt{R}\edmargin{sm}{not true: they have a (unique) representative in \texttt{R} but need not themselves be in \texttt{R}} because they are being processed. So, $\textsc{Live} \subseteq \texttt{R}$.\\
    By L.6-7 of Algorithm \ref{alg:seqsetbased}, $\textsc{Visited} \subseteq \texttt{R}$.\\
    L.9-10 ensure that no explored node is pushed in \texttt{R}.\\
    L.24-25 keep the invariant by unstacking explored nodes from \texttt{R}, so $\texttt{R} \cap \textsc{Explored} = \varnothing$. Thus, $\texttt{R} = \textsc{Visited} \setminus \textsc{Explored} = \textsc{Live}$.
\end{proof}

\begin{corollary}[Strong version]\label{cor:cor1}
    \begin{equation*}
        \forall v \in \textsc{Live}, \exists!~r \in \texttt{R} \cap \mathcal{S}(v), \mathcal{S}(v) = \mathcal{S}(r)
    \end{equation*}
\end{corollary}
\begin{proof}
    Let $v \in \textsc{Live} = \displaystyle{\biguplus_{r \in \texttt{R}} \mathcal{S}(r)}$. $v$ is in a unique partial SCC $\mathscr{S} := \mathcal{S}(v)$. Because of lemma \ref{lemma:disjointness}, there cannot exist $x \neq y \in \texttt{R}$ s.t. $\mathcal{S}(x) = \mathcal{S}(y) = \mathscr{S}$. Thus, there exists a unique $x \in \texttt{R}$ s.t. $\mathcal{S}(x) = \mathscr{S}$ (and $x\in \texttt{R} \cap \mathscr{S}$).
\end{proof}

\begin{corollary}[Weak version]\label{cor:cor2}
    \begin{equation*}
        \forall v \in \mathcal{V}, \forall w \in \textsc{Post}(v), w \in \textsc{Live} \implies \exists w' \in \texttt{R}, \mathcal{S}(w') = \mathcal{S}(w)
    \end{equation*}
\end{corollary}

\begin{proof}
    Holds because of corollary \ref{cor:cor1}.
\end{proof}

\begin{remark}
    In the algorithm \ref{alg:seqsetbased}, this property is maintained by L.16-18. These lines also illustrate how the algorithm ``reads'' the SCCs. Corollary \ref{cor:cor2} shows that when the mapped representatives of the top two nodes of \texttt{R} are united (until $\mathcal{S}(w') = \mathcal{S}(v) = \mathcal{S}(w)$ since $w'$ has a path to $v$), then all united components are in the same SCC.
\end{remark}

\begin{remark}\label{rem:proof}
    Because \texttt{R} only contains exactly one representative for each partial SCC (corollary \ref{cor:cor1} and remark \ref{rem:rootSCC}), after each step of the main loop -- \textit{i.e.} the DFS -- every partial SCC is actually maximal in the current set of visited nodes.
\end{remark}

\begin{theorem}
    The sequential algorithm \ref{alg:seqsetbased} is correct, \textit{i.e.} it returns a set of maximal SCCs.
\end{theorem}
\begin{proof}
    Holds by remark \ref{rem:proof}.
\end{proof}

\ednote{sm}{Should be strengthened to ``the set of maximal SCCs reachable from $v_0$.}

\ednote{sm}{A figure illustrating the execution of the algorithm would be nice, also in the talk presenting the project.}

\pagebreak

\subsection{Prerequisites for the formal proof}
Since the informal proof seems to be convincing, the formal -- checked automatically -- proof can be written in Isabelle (HOL) based on the basis of the reasoning developed above.

\subsubsection{Environment setup}\label{envdef}
The first definitions should be the different structures used in the algorithm. In particular, a record containing all the sets needed and described in the pseudo-code of algorithm \ref{alg:seqsetbased}. The environment has a generic type parameter, which is used to represent the type of the nodes in the graph (often integers):

\isa{
    {\color{isa_blue}record} \generic{v} env =\\
    $~~~\mathcal{S}$ :: "\generic{v} $\Rightarrow$ \generic{v} set"\\
    $~~~$explored :: "\generic{v} set"\\
    $~~~$visited :: "\generic{v} set"\\
    $~~~$sccs :: "\generic{v} set set"\\
    $~~~$stack :: "\generic{v} list"\\
}

The following lines define a graph structure and some useful natural relations:

\isa{
    {\locale} graph =\\
    $~~~$\fixes{} {\color{isa_dark_blue} vertices} :: "\generic{v} set" \and{} {\color{isa_dark_blue} successors} :: "\generic{v} $\Rightarrow$ \generic{v} set"\\
    $~~~$\assumes{} vfin: "finite {\color{isa_dark_blue}vertices}"\\
    $~~~$\and{} sclosed: "$\forall {\text{{\color{isa_dark_green}x}}} \in$ {\color{isa_dark_blue}vertices}. {\color{isa_dark_blue}successors} {\color{isa_dark_green}x} $\subseteq$ {\color{isa_dark_blue}vertices}"\\
}

The use of \texttt{successors} instead of an adjacency matrix, for instance, is a consequence of the fact that the algorithm is only concerned with the topological ordering of the nodes. For instance, nodes can represent integers, logical propositions or sets of states in a proving system for example.

\subsubsection{Reachability}
Now that graphs are defined, the reachability can be defined. Defining an edge is simply some rewriting of being a successor of one node.

\isa{
    \abbreviation{} edge \where\\
    $~~~$"{\color{isa_dark_blue}edge} {\color{isa_dark_green}x y} $\equiv$ {\color{isa_dark_green}y} $\in$ {\color{isa_dark_blue}successors} {\color{isa_dark_green}x}"
}
\BlankLine
\BlankLine
\BlankLine
\BlankLine

\noindent
Regarding the reachability binary relation, a choice has to be made since there are several ways to define it. In particular, there are two possible keywords, {\color{isa_blue}\texttt{inductive}} and {\color{isa_blue}\texttt{fun}}, respectively for an inductive or recursive definition. If both definitions are valid, the inductive one is kept for the following reasons. Although a recursive definition allows one to do some rewriting in the middle of terms, a recursive definition expresses both the positive and negative information\footnote{In this case, the positive information designates the fact of being reachable and the negative information designates the fact of not being reachable.} whereas the inductive one only expresses the positive information directly. Therefore, with an inductive definition, the negative information has to be proved. One would be right to argue that it would be more convenient to be able to tell without proving it that two nodes are not reachable from each other, but this does not interest us for the following. Another important point is that there is no datatype for a recursive definition, especially in this case with the transitive closure of the $\Rightarrow^*$ relation. Thus, the choice of the inductive definition is not a choice of simplicity but of necessity. Lastly, Isabelle will generate a simple inductive rule for the proofs split into the reflexive case, which stands in the definition, and the transitive case, which has to be proved.

\ednote{sm}{I don't really understand the prose above. A recursive function definition has to be based on some underlying inductive definition, which is simply not available for graphs. You say this, but the beginning of the paragraph seems to say otherwise. I'd just say that Isabelle provides a construction for inductive predicate definitions, which is appropriate here, and then explain that the two clauses represent the reflexive case and the extension of reachability by prepending an edge.}

\isa{
    \inductive{} reachable \where\\
    $~~~$reachable\_refl[iff]: "{\color{isa_dark_blue}reachable} {\color{isa_dark_green}x x}"\\
    $~{\text{|}}$ reachable\_succ[elim]: "$\ldb$edge {\color{isa_dark_green}x y};  {\color{isa_dark_blue}reachable} {\color{isa_dark_green}y z}$\rdb \Longrightarrow$ {\color{isa_dark_blue}reachable} {\color{isa_dark_green}x z}"\\
}

\ednote{sm}{I'm afraid that the blue color used for \texttt{reachable} here can be confusing, although Isabelle indeed displays the definition in this way. I'd make it black throughout.}

In order to be able to use those relations in the proofs later, it is essential to prove a list of lemmas, namely all the different natural properties that Isabelle cannot deduce\footnote{That is an abuse of language. The idea is for example that for the moment, there is no formal link between \texttt{edge} and \texttt{reachable}. The goal is to formalize it so Isabelle is logically able to both use and simplify some results in the proofs.} from nothing\footnote{There is actually a theorem fetcher that is particularly useful to find a basic set of lemmas.}. For instance, the following lemmas are essential.

\isa{
\lm{} succ\_reachable:\\
$~~~~~$\assumes{} "reachable {\color{isa_dark_blue}x y}" \and{} "edge {\color{isa_dark_blue}y z}"\\
$~~~~~$\shows "reachable {\color{isa_dark_blue}x z}"\\
$~~~~~${\color{isa_blue}using} assms {\color{isa_blue}by} induct auto\\
}
Mathematical writing: $\forall x, \forall y, \forall z, (x \Rightarrow^* y \wedge y \Rightarrow z) \Longrightarrow x \Rightarrow^* z$

\ednote{sm}{Note that this is the ``mirror'' of clause \texttt{reachable\_succ} (appending an edge).}

\isa{
\lm{} reachable\_trans:\\
$~~~~~$\assumes{} y: "reachable \blue{x y}" \and{} z: "reachable \blue{y z}"\\
$~~~~~$\shows{} "reachable \blue{x z}"\\
$~~~~~${\color{isa_blue}using} assms {\color{isa_blue}by} induct auto\\
}
Mathematical writing: $\forall x, \forall y, \forall z, (x \Rightarrow^* y \wedge y \Rightarrow^* z) \Longrightarrow x \Rightarrow^* z$\\

As the formal proofs will enventually deal with strongly connected components, it is also essential to formally define SCCs. For the purpose of the proof, the property of being a SCC is called \texttt{sub\_scc} and being a \textit{maximal} SCC is called \texttt{is\_scc} :

\isa{
{\color{isa_blue}definition} is\_subscc \where\\
$~~~~~$"is\_subscc S $\equiv \forall$ x $\in$ S. $\forall$ y $\in$ S. reachable x y"\\
}
Mathematical writing: A set $S$ is a SCC if $\forall x \in S, \forall y \in S, x \Rightarrow^* y$

\isa{
{\color{isa_blue}definition} is\_scc \where\\
$~~~~~$"is\_scc S $\equiv$ S $\neq$ \{\} $\wedge$ is\_subscc S\\
$~~~~~\wedge$ ($\forall$ S'. S $\subseteq$ S' $\wedge$ is\_subscc S' $\longrightarrow$ S' = S)"\\
}
Mathematical writing: A non-empty SCC $S$ is maximal if for all SCC $S'$, $S \subseteq S' \Longrightarrow S'=S$\\

Once again, there are some lemmas to prove, such as telling Isabelle when an element can be added to a SCC, or that two vertices that are reachable from each other are in the same SCC, or that two SCCs having a common element are identical.\\

\ednote{sm}{``Telling Isabelle'' sounds like you are introducing an axiom. Rather, these facts are deduced using Isabelle from the above definitions.}


\subsubsection{Equivalence relation and graph partition}
In the algorithm \ref{alg:seqsetbased}, the SCCs are progressively tracked in \texttt{sccs} and the equivalence relation $\mathcal{S}$ is updated with the \textsc{Unite} function. In Isabelle, a first recursive definition was written as follows:

\ednote{sm}{Note that this is different from the \textsc{Unite} function introduced earlier, and perhaps rename one of the two. Also, I'd introduce this function together with the \texttt{dfs} and \texttt{dfss} functions where it is used. Finally, the heading of the subsection doesn't seem to fit the text.}

\isa{
    {\color{isa_blue}function} unite :: "\generic{v} $\Rightarrow$ \generic{v} $\Rightarrow$ \generic{v} env $\Rightarrow$ \generic{v} env" \where{}\\
    "\blue{unite} \green{v w e} =\\
    $~~~$({\color{isa_blue}if} ($\mathcal{S}$ \green{e v} = $\mathcal{S}$ \green{e w}) \bblue{then} \green{e}\\
    $~~~$\bblue{else let} \green{r} = hd(stack \green{e});\\
    $~~~~~~~~~~~~$\green{r'}= hd(tl(stack \green{e}));\\
    $~~~~~~~~~~~~$\green{joined} = $\mathcal{S}$ \green{e r} $\cup$ $\mathcal{S}$ \green{e r};\\
    $~~~~~~~~~~~~$\green{e'}= \green{e}\env{\\
    $~~~~~~~~~~~~~~~$stack := tl(stack \green{e}),\\
    $~~~~~~~~~~~~~~~\mathcal{S}$ := ($\lambda$ n. \bblue{if} n $\in$ \green{joined} \bblue{then} \green{joined} \bblue{else} $\mathcal{S}$ \green{e n})\\
    $~~~~~~~~~~~~$}\\
    $~~~$\bblue{in} \blue{unite} \green{v w e'})"\\
    $~~~$\bblue{by} pat\_completeness auto
}

\BlankLine

However, this definition makes the proofs too difficult due to the recursion. An imperative version was therefore written:

\isa{
    \bblue{definition} unite :: "\generic{v} $\Rightarrow$ \generic{v} $\Rightarrow$ \generic{v} env $\Rightarrow$ \generic{v} env" \where{}\\
    $~~~$"\blue{unite} \green{v w e} $\equiv$\\
    $~~~~~~$\bblue{let} \green{pfx} = takeWhile ($\lambda$\green{x}. \green{w} $\notin$ $\mathcal{S}$ \green{e x}) (stack \green{e});\\
    $~~~~~~~~~~$\green{sfx} = dropWhile ($\lambda$\green{x}. \green{w} $\notin$ $\mathcal{S}$ \green{e x}) (stack \green{e});\\
    $~~~~~~~~~~$\green{cc} = $\bigcup$ \{$\mathcal{S}$ \green{e x} $|$ \green{x}. \green{x} $\in$ set \green{pfx} $\cup$ \{hd \green{sfx}\}\}\\
    $~~~~~~$\bblue{in}  \green{e}\env{$\mathcal{S}$ := $\lambda$\green{x}. \bblue{if} \green{x} $\in$ \green{cc} \bblue{then} \green{cc} \bblue{else} $\mathcal{S}$ \green{e x}, stack := \green{sfx}}"
}
    
\BlankLine
\BlankLine

The idea of this definition is to create a partition of \texttt{stack e = pfx @ sfx} such that \texttt{pfx} contains the nodes which are to be merged into \texttt{$\mathcal{S}$ e w} and \texttt{sfx} contains the root of \texttt{$\mathcal{S}$ e w} followed by the rest of the stack. Then, \texttt{cc} -- which stands for \textit{connected component} -- contains all the nodes which are equivalent to \texttt{w} in the sub-graph currently explored. The function \texttt{takeWhile} applied to a boolean function \texttt{P}\footnote{\texttt{P :: \generic{a} $\Rightarrow$ bool}} seen as a property and a list \texttt{xs} returns the elements of \texttt{xs} which satisfy \texttt{P} and stops at the first element not satisfying \texttt{P}. The function \texttt{dropWhile} is the opposite of \texttt{takeWhile}. Both the imperative and recursive versions of \texttt{unite} are equivalent.

\ednote{sm}{The two are equivalent within the context of the algorithm, not in general. And the equivalence has not been proved. In fact, the non-recursive (why ``imperative''?) definition is intended to be simpler for the proof because it avoids introducing separate pre- and post-conditions for the function and proving such a ``contract''.}

\subsubsection{Ordering relation}\label{sec:orderingrelation}
In the proof, a precedence relation\footnote{In fact, a total order is being defined on stacks.}\edmargin{sm}{partial? don't have $x \preceq y \lor y \preceq x$} noted {\color{isa_dark_blue}$\bullet~\preceq~\bullet~\text{in}~\bullet$} will be needed on the stack. Let $x$ and $y$ be two nodes and $R$ be a stack. Informally, $x$ precedes $y$ in $R$ if $y$ was pushed in $R$ before $x$ (see \textsc{Figure} \ref{fig:stackorder}).

\begin{figure}[!h]
    \ctikzfig{stackorder}
    \caption{The ordering relation on stacks\label{fig:stackorder}}
\end{figure}

\begin{definition}[Ordering relation]
    Let $x$ and $y$ be two nodes and $xs$ be a stack.
    \begin{equation*}
        x \preceq y~\text{in}~xs \equiv \exists~h,~\exists~r,~(xs = h @ [x] @ r) \wedge (y \in [x]@r)
    \end{equation*}
\end{definition}


The idea is to later use the following property: if $x \preceq y~\text{in}~xs$, then $y \Rightarrow^* x$.\\
It is defined in Isabelle as follows:\\
\isa{
    {\color{isa_blue}definition} precedes ("\_ $\preceq$ \_ in \_" [100,100,100] 39) \where\\
$~~~~~$"{\color{isa_dark_green}x} $\preceq$ {\color{isa_dark_green}y} in {\color{isa_dark_green}xs} $\equiv$ $\exists${\color{isa_dark_green}h} {\color{isa_dark_green}r}. {\color{isa_dark_green}xs} = {\color{isa_dark_green}h} @ ({\color{isa_dark_green}x} \# {\color{isa_dark_green}r}) $\wedge$ {\color{isa_dark_green}y} $\in$ set ({\color{isa_dark_green}x} \# {\color{isa_dark_green}r})"\\
}

All the different properties (\textit{i.e.} lemmas) which follow this definition in the Isabelle implementation are detailed in the natural mathematical writing in the \nameref{appendix}. The right part of the notation represents the orders of priority for each operand since $\preceq$ is an infix operator.

\subsubsection{Implementation of the algorithm}

Now that the environment is set up, the actual algorithm -- seen as a function -- can be implemented.
Since Isabelle does not support loops, the implementation will be split into two mutually recursive functions. The main function is called \texttt{dfs} and takes its name after the Depth First Search algorithm because the algorithm \ref{alg:seqsetbased} roughly consists in a deep traversal of a graph. The second function is called \texttt{dfss} and represents the \textit{while} loop\edmargin{sm}{\textbf{foreach} loop?!} of the algorithm \ref{alg:seqsetbased}. The two functions are mutually recursive because they recursively call each other. In particular, \texttt{dfss} will call either\edmargin{sm}{both itself and \texttt{dfs}} itself or \texttt{dfs}, depending on the case.

\isa{
    {\color{isa_blue}{function}} dfs :: "\generic{v} $\Rightarrow$ \generic{v} env $\Rightarrow$ \generic{v} env" \and{}\\
    $~~~~~~~~~~$dfss:: "\generic{v} $\Rightarrow$ \generic{v} set $\Rightarrow$ \generic{v} env $\Rightarrow$ \generic{v} env" \where\\
    "{\color{isa_dark_blue}dfs} {\color{isa_dark_green}v e} =\\
    $~~~~~$({\color{isa_blue}{let}} {\color{isa_dark_green}e1} = {\color{isa_dark_green}e}\env{visited := visited e $\cup$ \{{\color{isa_dark_green}v}\}, stack := ({\color{isa_dark_green}v} \# stack {\color{isa_dark_green}e})};\\
    $~~~~~~~~~~${\color{isa_dark_green}e'} = {\color{isa_dark_blue}dfss} {\color{isa_dark_green}v} (successors {\color{isa_dark_green}v}) {\color{isa_dark_green}e1}\\
    $~~~~~${\color{isa_blue}{in if}} {\color{isa_dark_green}v} = hd(stack {\color{isa_dark_green}e'})\\
    $~~~~~~~~~~${\color{isa_blue}{then}} {\color{isa_dark_green}e'}\env{sccs:=sccs {\color{isa_dark_green}e'} $\cup$ {$\mathcal{S}$ {\color{isa_dark_green}e' v}}, explored:=explored {\color{isa_dark_green}e'} $\cup$ ($\mathcal{S}$ {\color{isa_dark_green}e' v}), stack:=tl(stack {\color{isa_dark_green}e'})}\\
    $~~~~~~~~~~${\color{isa_blue}else} {\color{isa_dark_green}e'})"\\
    | "{\color{isa_dark_blue}dfss} {\color{isa_dark_green}v vs e} =\\
    $~~~~~$({\color{isa_blue}if} {\color{isa_dark_green}vs} = \{\} {\color{isa_blue}then} {\color{isa_dark_green}e}\\
    $~~~~~${\color{isa_blue}else} ({\color{isa_blue}let} {\color{isa_dark_green}w} = SOME {\color{isa_dark_green}x}. {\color{isa_dark_green}x} $\in$ {\color{isa_dark_green}vs}\\
    $~~~~~~~~~~${\color{isa_blue}in} ({\color{isa_blue}let} {\color{isa_dark_green}e'} = ({\color{isa_blue}if} {\color{isa_dark_green}w} $\in$ explored {\color{isa_dark_green}e} {\color{isa_blue}then} {\color{isa_dark_green}e}\\
    $~~~~~~~~~~~~~~~~~~~${\color{isa_blue}else if} {\color{isa_dark_green}w} $\notin$ visited {\color{isa_dark_green}e} {\color{isa_blue}then} {\color{isa_dark_blue}dfs} {\color{isa_dark_green}w e}\\
    $~~~~~~~~~~~~~~~~~~~${\color{isa_blue}else} unite {\color{isa_dark_green}v w e})\\
    $~~~~~~~~~~~~~~${\color{isa_blue}in} {\color{isa_dark_blue}dfss} {\color{isa_dark_green}v} ({\color{isa_dark_green}v} - \{{\color{isa_dark_green}w}\}) {\color{isa_dark_green}e'})))"\\
    $~~~${\color{isa_blue}by} pat\_completeness (force\bblue{+})\\
}

The two last keywords require explanations as well : \texttt{pat\_completeness} stands for \textit{pattern completeness} and ensures that there is no missing patterns. The keyword \texttt{force} is used\footnote{\texttt{force} is more aggressive in instantiation and seems to find the right instance.} to help Isabelle know -- by proving it -- that both \texttt{dfs} and \texttt{dfss} are actually functions and that those functions are well defined with respect to the usual logical and mathematical meaning.

\ednote{sm}{\texttt{force} finishes the proof of pattern completeness, the proof of termination remains open, and it would actually show that these are well-defined functions. Also, you should say that \texttt{force} is more aggressive \emph{than \texttt{auto}}.}

\pagebreak

\subsection{Formal proof}
\subsubsection{General scheme}
As the algorithm is composed of two mutually recursive functions, the correctness of the algorithm is proved by induction on the environment structure (cf \ref{envdef}).\edmargin{sm}{mutual induction on the functions? There is no induction principle for environments.} Since both \texttt{dfs} and \texttt{dfss} are quite complex, the proof is split into several parts. The idea is to prove for each function that its execution given some pre-conditions on the input environment implies some post-conditions on the output environment. Then, it has to be made for the mutually recursive calls as well, so that given the same pre-conditions on one function, the pre-conditions on the other function are also satisfied. Finally, it has to be proved that if the pre-conditions are satisfied for one function, and if the pre-conditions imply the post-conditions on the other function, then the post-conditions are also satisfied for the first function.

\subsubsection{Well-formedness of the environment}
The whole proof relies on one big invariant regarding the environment structure. It defines the fact for an environment to be well-formed. This invariant is a conjunction of several properties and is defined as follows:

\isa{
    \bblue{definition} wf\_env \where{}\\
    $~~~$"\blue{wf\_env} \green{e} $\equiv$\\
    $~~~~~~$distinct (stack \green{e})\\
    $~~~~\wedge$ set (stack \green{e}) $\subseteq$ visited \green{e}\\
    $~~~~\wedge$ explored \green{e} $\subseteq$ visited \green{e}\\
    $~~~~\wedge$ explored \green{e} $\cap$ set (stack \green{e}) = \{\}\\
    $~~~~\wedge$ ($\forall$ \green{v} \green{w}. \green{w} $\in$ $\mathcal{S}$ \green{e} \green{v} $\longleftrightarrow$ ($\mathcal{S}$ \green{e} \green{v} = $\mathcal{S}$ \green{e} \green{w}))\\
    $~~~~\wedge$ ($\forall$\green{v} $\in$ set (stack \green{e}).$\forall$ \green{w} $\in$ set (stack \green{e}).\green{v} $\neq$ \green{w} $\longrightarrow$ $\mathcal{S}$ \green{e} \green{v} $\cap$ $\mathcal{S}$ \green{e} \green{w} = \{\})\\
    $~~~~\wedge$ ($\forall$ \green{v}. \green{v} $\notin$ visited \green{e} $\longrightarrow$ $\mathcal{S}$ \green{e} \green{v} = \{\green{v}\})\\
    $~~~~\wedge$ $\bigcup$ \{$\mathcal{S}$ \green{e} \green{v} $|$ \green{v}. \green{v} $\in$ set (stack \green{e})\} = visited \green{e} - explored \green{e}\\
    $~~~~\wedge$ ($\forall$ \green{x} \green{y}. \green{x} $\preceq$ \green{y} in stack \green{e} $\longrightarrow$ reachable \green{y} \green{x})\\
    $~~~~\wedge$ ($\forall$ \green{x}. is\_subscc ($\mathcal{S}$ \green{e} \green{x}))\\
    $~~~~\wedge$ ($\forall$ \green{x} $\in$ explored \green{e}. $\forall$ \green{y}. reachable \green{x} \green{y} $\longrightarrow$ \green{y} $\in$ explored \green{e})\\
    $~~~~\wedge$ ($\forall$ \green{S} $\in$ sccs \green{e}. is\_scc \green{S})"
}

\BlankLine
\BlankLine

Let us take a closer look to this invariant, taken in the same order as the definition above:
\begin{itemize}
    \item[$\bullet$] First, the stack is a list of distinct elements.
    \item[$\bullet$] All elements of the stack are visited.
    \item[$\bullet$] The set of explored nodes is a subset of the set of visited nodes.
    \item[$\bullet$] Explored nodes cannot be in the stack.
    \item[$\bullet$] The three next properties are about the equivalence relation $\mathcal{S}$.
    \item[$\bullet$] The union of the sets of equivalent nodes in the stack is equal to the set of visited nodes minus the set of explored nodes.
    \item[$\bullet$] A node in the stack can reach all nodes before it in the stack (\textit{i.e.} pushed later).
    \item[$\bullet$] $\mathcal{S}$ represents a set of strongly connected components (not maximal).
    \item[$\bullet$] For all explored nodes, the sub-graph induced by their successors is totally explored.
    \item[$\bullet$] \texttt{sccs} is a set of maximal SCCs
\end{itemize}
\noindent
These properties are natural and most of them are easy to prove.

\ednote{sm}{Actually, there is a bit of redundancy here. For example, the second and fourth conjunct follow from the fifth and eighth. This is not a bad thing per se since it may help automatic proof, but could be discussed.}

\BlankLine
\BlankLine

It is also useful to induce a notion of monotonicity on the environments during the execution of the algorithm. This is defined as follows through the definition of an ordering relation on environments:

\isa{
\bblue{definition} sub\_env \where\\
"\blue{sub\_env} \green{e e'} $\equiv$\\
$~~~~$visited \green{e} $\subseteq$ visited \green{e'}\\
$~~$$\wedge$ explored \green{e} $\subseteq$ explored \green{e'}\\
$~~$$\wedge$ ($\forall$ \green{v}. $\mathcal{S}$ \green{e v} $\subseteq$ $\mathcal{S}$ \green{e' v})\\
$~~$$\wedge$ ($\bigcup$\{$\mathcal{S}$ \green{e v} $|$ \green{v}. \green{v} $\in$ set (stack \green{e})\}) $\subseteq$ ($\bigcup$\{$\mathcal{S}$ \green{e' v} $|$ \green{v}. \green{v} $\in$ set (stack \green{e'})\})"
}

\ednote{sm}{Add a bit of explanation, as for the basic invariant above, in particular for the last conjunct.}

\BlankLine
\BlankLine

\subsubsection{\texttt{dfs} pre- and post-conditions}
The pre-conditions of \texttt{dfs} are rather simple. The environment must be well-formed and the node must not be visited. There is also a condition on the reachability of the nodes in the stack and the node on which the function is called, but once again this condition is rather natural to consider since \texttt{dfs} is performing a DFS graph traversal:

\isa{
\bblue{definition} pre\_dfs \where\\
$~~$"\blue{pre\_dfs} \green{v e} $\equiv$\\
$~~~~$wf\_env \green{e}\\
$~~$$\wedge$ \green{v} $\notin$ visited \green{e}\\
$~~$$\wedge$ ($\forall$ \green{n} $\in$ set (stack \green{e}). reachable \green{n v})"
}

\BlankLine
\BlankLine

The post-conditions are a little more complex since it has to consider the new environment with the new visited / explored nodes, the new state of the stack and the updates in $\mathcal{S}$:

\isa{
\bblue{definition} post\_dfs \where\\ 
"\blue{post\_dfs} \green{v prev\_e e} $\equiv$\\
$~~~~$wf\_env \green{e}\\
$~~\wedge$ ($\forall$ \green{x}. reachable \green{v} \green{x} $\longrightarrow$ \green{x} $\in$ visited e)\\
$~~\wedge$ sub\_env \green{prev\_e} \green{e}\\
$~~\wedge$ ($\forall$ \green{n} $\in$ set (stack \green{e}). reachable \green{n} \green{v})\\
$~~\wedge$ ($\exists$ \green{ns}. stack \green{prev\_e} = ns @ (stack \green{e}))\\
$~~\wedge$ ($\forall$ \green{m n}. $\stackprec{m}{n}{prec\_e}$ $\longrightarrow$ \\ $~~~~~~$ ($\forall$ \green{u} $\in$ $\mathcal{S}$ \green{prev\_e m}. reachable \green{u} \green{v} $\wedge$ reachable \green{v} \green{n} $\longrightarrow$ $\mathcal{S}$ \green{e m} = $\mathcal{S}$ \green{e n}))\\
$~~\wedge$ ((\green{v} $\in$ explored \green{e} $\wedge$ stack \green{e} = stack \green{prev\_e}) $\lor$ \green{v} $\in$ $\mathcal{S}$ \green{e} (hd (stack e)))"
}

\ednote{sm}{Add some explanations, and continue \dots}

\ednote{sm}{Don't forget to write a conclusion, explaining what has been done, what is missing / could be improved, and what your experience has been.}

\pagebreak

\section{Appendix}\label{appendix}
\subsection{Some lemmas}
Those lemmas refer to the precedence relation introduced in \textsc{Section} \ref{sec:orderingrelation}.
\BlankLine
Let $x, y, z$ be three nodes, and let $xs, ys, zs$ be three lists of nodes representing stacks.\\
By abuse of language, if an element is on a stack, it is in the set of elements contained in the stack so the following statement can be written: $x$ is on $xs \Longleftrightarrow x \in xs$. However, $xs$ in not seen as the set representing $xs$ since an element may occur several times in a stack.\\
The operator $@$ denotes the concatenation and operates on two lists: $[x_0, \dots, x_n] @ [y_0, \dots, y_m] = [x_0, \dots, x_n, y_0, \dots, y_m]$.\\

\begin{flushleft}
    (i)
$x \preceq y~\text{in}~xs \Longrightarrow (x \in xs)\wedge(y \in xs)$
\end{flushleft}
\begin{flushleft}
    (ii)
$y \in [x] @ xs \Longrightarrow x \preceq y~\text{in}~([x] @ xs)$
\end{flushleft}

\begin{flushleft}
    (iii)
    $x \neq z \Longrightarrow (x \preceq y~\text{in}~([z] @ zs) \Longrightarrow x \preceq y ~\text{in}~zs)$
\end{flushleft}

\begin{flushleft}
    (iv)
    $(y \preceq x~\text{in}~([x] @ xs)) \wedge (x \notin xs) \Longrightarrow (x = y)$
\end{flushleft}

\begin{flushleft}
    (v)
    $y \in (ys @ [x]) \Longrightarrow y \preceq x~\text{in}~(ys @ [x] @ xs)$
\end{flushleft} 

\begin{flushleft}
    (vi)
    $(x \preceq x~\text{in}~xs) = (x \in xs)$
\end{flushleft}

\begin{flushleft}
    (vii)
    $x \preceq y~\text{in}~xs \Longrightarrow x \preceq y~\text{in}~(ys @ xs)$
\end{flushleft}

\begin{flushleft}
    (viii)
    $x \notin ys \Longrightarrow (x \preceq y~\text{in}~(ys @ xs) \Longleftrightarrow x \preceq y~\text{in}~xs)$
\end{flushleft}

\begin{flushleft}
    (ix)
    $x \preceq y~\text{in}~xs \Longrightarrow x \preceq y~\text{in}~(xs @ ys)$
\end{flushleft}

\begin{flushleft}
    (x)
    $y \notin ys \Longrightarrow x \preceq y~\text{in}~(xs @ ys) \Longleftrightarrow x \preceq y~\text{in}~xs$
\end{flushleft}

\begin{flushleft}
    (xi)(transitivity)
    $(x \preceq y~\text{in}~xs) \wedge (y \preceq z~\text{in}~xs) \wedge \underset{\text{all elements of $xs$ are distinct}}{\underbrace{(\forall~0 \leq i < j \leq \text{length}(xs), xs[i] \neq xs[j])}} \Longrightarrow x \preceq z~\text{in}~xs$
\end{flushleft}

\begin{flushleft}
    (xi)(antisymmetry)
    $(x \preceq y~\text{in}~xs) \wedge (y \preceq x~\text{in}~xs) \wedge \underset{\text{all elements of $xs$ are distinct}}{\underbrace{(\forall~0 \leq i < j \leq \text{length}(xs), xs[i] \neq xs[j])}} \Longrightarrow x = y$
\end{flushleft}

% continue with precedes_append_right_iff

\pagebreak


\begin{thebibliography}{99}

\bibitem{tarjanMerz} R. Chen, C. Cohen, J.-J. Lévy, S. Merz, L. Théry, \emph{Formal Proofs of Tarjan’s Strongly Connected Components Algorithm in Why3, Coq and Isabelle}, 2019

\bibitem{thesisBloemen} V. Bloemen, A. Laarman, J. van de Pol, \emph{Multi-Core On-The-Fly SCC Decomposition}, 2016

\bibitem{articleSCC} V. Bloemen, \emph{Strong Connectivity and Shortest Paths for Checking Models}, 2019

\end{thebibliography}

\ednote{sm}{Add a few more references, such as about Isabelle, and possibly other SCC algorithms (Dijkstra, Tarjan). For each reference, indicate where it was published, not just the year.}

\end{document}

