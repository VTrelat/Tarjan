\documentclass[a4 paper, 12pt]{article}
\usepackage{amsmath, amsthm, amsfonts, amssymb, mathrsfs}
\usepackage{tikzit}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage[ruled,vlined, linesnumbered]{algorithm2e}

\input{style.tikzstyles}

%__________________________________________
\newcommand{\ldb}{\mathopen{\ooalign{\makebox[.4em][l]{$\lbrack$}\cr\makebox[.4em][r]{$\lbrack$}\cr}}}                                                       
\newcommand{\rdb}{\mathclose{\ooalign{\makebox[.4em][l]{$\rbrack$}\cr\makebox[.4em][r]{$\rbrack$}\cr}}}

%__________________________________________

\hypersetup{
    colorlinks=true,
    linktoc=false,
    linkcolor=blue,
    citecolor=blue
}

%__________________________________________
% Colors definition
\definecolor{isa_red}{RGB}{255, 58, 71}
\definecolor{isa_blue}{RGB}{0, 103, 158}
\definecolor{isa_green}{RGB}{0, 157, 97}
\definecolor{isa_dark_green}{RGB}{0,131, 0}
\definecolor{isa_purple}{RGB}{174, 5, 238}
\definecolor{isa_dark_blue}{RGB}{26, 0, 253}

% Isabelle keywords
\newcommand{\apply}{{\color{isa_red}{apply}}}
\newcommand{\done}{{\color{isa_red}{done}}}
\newcommand{\datatype}{{\color{isa_blue}{datatype}}}
\newcommand{\inductive}{{\color{isa_blue}{inductive}}}
\newcommand{\abbreviation}{{\color{isa_blue}{abbreviation}}}
\newcommand{\thm}{{\color{isa_blue}{theorem}}}
\newcommand{\lm}{{\color{isa_blue}{lemma}}}
\newcommand{\fun}{{\color{isa_blue}{fun}}}
\renewcommand{\locale}{{\color{isa_blue}{locale}}}
\newcommand{\where}{{\color{isa_green}{where}}}
\renewcommand{\and}{{\color{isa_green}{and}}}
\newcommand{\fixes}{{\color{isa_green}{fixes}}}
\newcommand{\assumes}{{\color{isa_green}{assumes}}}
\newcommand{\shows}{{\color{isa_green}{shows}}}
\newcommand{\generic}[1]{{\color{isa_purple}{\textquotesingle#1}}}
\newcommand{\isa}[1]{\small\texttt{\\\noindent#1}}
\newcommand{\blue}[1]{{\color{isa_dark_blue}{#1}}}
\newcommand{\green}[1]{{\color{isa_dark_green}{#1}}}
\newcommand{\env}[1]{$(\!|$#1$|\!)$}

\theoremstyle{definition}
\newtheorem{isabelle}{Isabelle}

\lstdefinelanguage{isabelle}{%
    keywords=[1]{type_synonym,datatype,fun,abbreviation,definition,proof,lemma,theorem,corollary},
    keywordstyle=[1]\bfseries\color{isarblue},
    keywords=[2]{where,assumes,shows,and},
    keywordstyle=[2]\bfseries\color{isargreen},
    keywords=[3]{if,then,else,case,of,SOME,let,in,O},
    keywordstyle=[3]\color{isarblue},
}
\lstset{%
  language=isabelle,
  escapeinside={&}{&},
  columns=fixed,
  extendedchars,
  basewidth={0.5em,0.45em},
  basicstyle=\ttfamily,
  mathescape,
}


%__________________________________________

\def\NN{$\mathcal{N}~$}
\def\GG{$\mathcal{G}~$}
\def\VV{$\mathcal{V}~$}
\def\EE{$\mathcal{E}~$}

\renewcommand\qedsymbol{$\blacksquare$}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{corollary}{Corollary}[lemma]
\newtheorem{remark}{Remark}

%__________________________________________

% Node styles
\tikzstyle{white node}=[fill=none, draw=black, shape=circle, tikzit fill=white, tikzit draw=black]
\tikzstyle{red node}=[fill={rgb,255: red,232; green,118; blue,188}, draw=black, shape=circle, tikzit fill={rgb,255: red,232; green,118; blue,188}, tikzit draw=black]
\tikzstyle{blue node}=[fill={rgb,255: red,179; green,191; blue,255}, draw=black, shape=circle, tikzit fill={rgb,255: red,179; green,191; blue,255}, tikzit draw=black]
\tikzstyle{green node}=[fill={rgb,255: red,201; green,255; blue,189}, draw=black, shape=circle, tikzit fill={rgb,255: red,201; green,255; blue,189}, tikzit draw=black]

\tikzstyle{arrow}=[>]
\tikzstyle{new style 0}=[fill=none, draw=red, shape=circle, tikzit fill=none]
\tikzstyle{arrow}=[<--]
\tikzstyle{new edge style 2}=[- - -]

% Edge styles
\tikzstyle{right arrow}=[->]
\tikzstyle{right red arrow}=[->, draw=red, tikzit draw=red]
\tikzstyle{left arrow}=[<-]
\tikzstyle{left red arrow}=[<-, draw=red, tikzit draw=red]
\tikzstyle{right dashed arrow}=[->, dashed=1, dash pattern=on 1mm off 1mm, draw=red]
\tikzstyle{left dashed arrow}=[<-, dashed=1, dash pattern=on 1mm off 1mm, draw=red]
\tikzstyle{blue fill}=[-, fill={rgb,255: red,179; green,191; blue,255}, draw=none, tikzit draw=none, tikzit fill={rgb,255: red,213; green,207; blue,255}]
\tikzstyle{green fill}=[-, fill={rgb,255: red,201; green,255; blue,189}, draw=none, tikzit draw=none, tikzit fill={rgb,255: red,213; green,255; blue,208}]
\tikzstyle{red fill}=[-, fill={rgb,255: red,232; green,118; blue,188}, draw=none, tikzit draw=none, tikzit fill={rgb,255: red,232; green,118; blue,118}]

%-----------------------------------------------------------------

\begin{document}
\newgeometry{margin=2cm}
\begin{titlepage}
    \begin{figure}[!h]
        \centering
        \includegraphics[height = .1\textwidth]{/Users/vincent/Documents/MinesNancy/logoartem.png}
        \hspace{1cm}
        \includegraphics[height = .1\textwidth]{img/logoloria.jpg}
        \hspace{1cm}
        \includegraphics[height = .1\textwidth]{img/logoUL.png}
    \end{figure}
    \vspace{3cm}

    \begin{center}
%        \huge{Strongly connected components algorithms : parallelization and proofs}
        \huge{Formal methods and assisted proofs: application to strongly connected components algorithms}
    \end{center}
    \vspace{1cm}
    \begin{center}
        \large{Département Informatique --- Parcours Recherche \\ Tuteur : Stephan Merz}
    \end{center}
    \vspace{1 cm}
    \begin{center}
        Vincent TRÉLAT
    \end{center}
    \vspace{2 cm}
    \begin{center}
        \textit{\today}
    \end{center}
    \vspace{2 cm}
    \begin{center}
        ***
    \end{center}
    
\end{titlepage}
\restoregeometry
\pagebreak
~
\pagebreak

\tableofcontents
\pagebreak

\section{Introduction}
\subsection{Academic context}
This research work was carried out as part of my curriculum at the french \href{https://mines-nancy.univ-lorraine.fr}{École des Mines de Nancy}. All documents such as codes or source papers are available on a \href{https://github.com/VTrelat/Tarjan}{GitHub repository}.

\subsection{Formal methods}
Formal methods are a field of computer science related to mathematical logic and reasoning. The whole purpose of the discipline is to ensure by a logical proof that a given algorithm is not only correct on its domain of definition, but also to find -- or define -- that domain. Formal methods find applications in a variety of fields, both concrete, such as the railway industry or self-driving cars, and abstract, such as computational architecture.\\
Altough a formal proof lies first on paper, the real formalisation starts when proofs are mechanised in a proof assistant.

\subsection{Isabelle (HOL)}
\begin{quote}
    Isabelle is a generic proof assistant. It allows mathematical formulas to be expressed in a formal language and provides tools for proving those formulas in a logical calculus.
\end{quote}
\begin{flushright}
    \href{https://isabelle.in.tum.de/}{isabelle.in.tum.de}
\end{flushright}
Isabelle is a really powerful low-level proof assistant coming with a higher order logic (HOL) proving environment making the proofs easily readible and comprehensible without adding any abstract overlay. The term "assistant" designates the fact that Isabelle has numerous tools allowing various automations in the proofs such as a theorem seeker or an automatic solver.

\subsection{Isabelle by example}
The following example is a good introduction to the use of Isabelle.

\pagebreak

\section{Models and representation}
\subsection{Nodes}
% Je pense que cette description n'a de sens que dans le contexte d'un algorithme particulier. Dans le document final il faudra commencer par décrire le problème indépendamment de l'algorithme utilisé pour le résoudre, d'autant plus qu'il y a deux algorithmes différents.

Vertices of a graph can be represented as nodes.
A node \NN is a simple data structure composed of an index, a boolean value telling if it has already been visited and two integer values \textit{num} and \textit{lowlink} whose role will be explained later.\\
In the following, the aforesaid attributes will be referred to through the following notation:\\
Let \NN be a node. The attributes of \NN can be accessed via \texttt{N.index}, \texttt{N.visited}, \texttt{N.num} and \texttt{N.lowlink}. This notation will be applied to any object that lends itself to it.

\subsection{Graphs and their representation}
A graph \GG is the data $(\mathcal{V}, \mathcal{E})$ where:
\begin{itemize}
    \item $\mathcal{V}$ is a set of vertices
    \item $\mathcal{E} \subseteq \{(x,y) \in V^2\}$ is a set of edges\footnote{Note the use of the couple $(x, y)$ and not the pair $\{x, y\}$ that makes the graph directed.}.
\end{itemize}
Vertices will often be called nodes and edges will be represented through adjency lists for each node.\\
Let us give an example. Let \GG = $(\mathcal{V}, \mathcal{E})$ be the graph represented on figure \ref{fig:graph}.
\begin{figure}[!h]
    \ctikzfig{graph}
    \caption{Representation of \GG\label{fig:graph}}
\end{figure}
Thus, \VV = $\{0,1,2,3,4,5,6,7\}$ and
\begin{flushleft}
    ~~~~~~~~\EE = $\{(0,0),(0,1),(0,2),(0,3),$\\
    $~~~~~~~~~~~~~~~(1,4),(1,7),$\\
    $~~~~~~~~~~~~~~~(3,0),(3,1),(3,2),(3,5),$\\
    $~~~~~~~~~~~~~~~(4,3),(4,6),$\\
    $~~~~~~~~~~~~~~~(5,6),$\\
    $~~~~~~~~~~~~~~~(6,3),$\\
    $~~~~~~~~~~~~~~~(7,6)\}$
\end{flushleft}

This representation being somewhat long, adjency lists can be used instead and therefore it gives:
\begin{center}
    \texttt{G.adjency = [[0,1,2,3],[4,7],[0,1,2,5],[3,6],[6],[3],[6]]}
\end{center}
Thus, for all $i \in \{0,\ldots,7\}$, \texttt{G.adjency[i]} is the list of nodes to which node $i$ is connected -- \textit{i.e.} there is an directed edge from node $i$ to every node of \texttt{G.adjency[i]}.
\pagebreak

\section{Formalisation}
\subsection{Strongly connected components}
\subsubsection{Directed graphs}\label{sec:directedgraphs}
\begin{definition}
    For two vertices $x$ and $y$ of \VV, the relation "has an edge to" is noted "$\Rightarrow$" such that
    \begin{equation*}
        (x, y) \in \mathcal{E} \Longleftrightarrow x \Rightarrow y
    \end{equation*}
    By extension, if there is a path from $x$ to $y$ with more than one edge, the same notation is kept for the sake of simplicity.
    The reflexive and transitive closure of the relation $\Rightarrow$ is noted $\Rightarrow^*$.
\end{definition}

\begin{definition}
    Let \GG = (\VV, \EE) be an directed graph.
$\mathcal{C} \subseteq \mathcal{V}$ is a strongly connected component of \GG if:
\begin{gather*}
    \forall x, y \in \mathcal{C}, (x \Rightarrow y) \wedge (y \Rightarrow x)
\end{gather*}
\textit{i.e.} there is a path between every $x$ and $y$ in $\mathcal{C}$.\\

\end{definition}

\subsubsection{Examples}
\begin{figure}[!h]
    \centering
    \begin{subfigure}[t]{.49\textwidth}
        \ctikzfig{example2}
        \subcaption{Strongly connected graph}
    \end{subfigure}
    \begin{subfigure}[t]{.49\textwidth}
        \ctikzfig{example3}
        \subcaption{Not strongly connected graph}
    \end{subfigure}
    \caption{Basic example of what is a small SCC}
\end{figure}
\begin{figure}[!h]
    \ctikzfig{exampleSCC}
    \caption{Example of a graph where each colored set of node is a maximal set of SCC\label{fig:exampleSCC}}
\end{figure}

\begin{figure}[!h]
    \ctikzfig{exampleSCCreduced}
    \caption{Reduced visualization of the graph represented if figure \ref{fig:exampleSCC}}
\end{figure}

\subsection{Order of traversal and backtracking edges}
\subsubsection{DFS and \textit{num} value}
Tarjan's SCC algorithm basically lies on a depth-first search. The figure \ref{fig:dfs} shows an example of a DFS traversal on a simple directed graph.
\begin{figure}[!h]
    \ctikzfig{dfs}
    \caption{Example of a DFS\label{fig:dfs}}
\end{figure}

The previously mentioned figure also displays in red the \texttt{num} value which represents the order in which the nodes are visited in the graph during the DFS.

\subsubsection{Backtracking edges}
\begin{definition}
    Given a graph \GG and an order of traversal in this graph, \textit{i.e.} each node of \GG has a unique value $\texttt{num} \in [0,~|\mathcal{V}|]~$ and two nodes $u$ and $v$, there is a backtracking edge from $v$ to $u$ if:
    \begin{equation*}
        \left\{
            \begin{array}{l}
                \texttt{u.num} < \texttt{v.num}\\
                v~\Rightarrow~u,~\textit{i.e. }~(v, u) \in \mathcal{E}\\
            \end{array}
        \right.
    \end{equation*}
    In this case, the backtracking edge from $v$ to $u$ is represented by $v \hookrightarrow u$.\\      
\end{definition}


\subsection{Lowlink value}
\subsubsection{Definition}
Informally, the \texttt{lowlink} value of a node represents the \texttt{num} value of the attachment node of their SCC, \textit{i.e.} the \texttt{num} value of the entrance node in the corresponding SCC.\\

A more formal definition would be the following:
\begin{definition}
    Let $u$ be a node.
    \begin{equation*}
        \texttt{u.lowlink} = \min \{\texttt{w.num}~|~\exists~v\in \mathcal{V},~u \Rightarrow v \hookrightarrow w\}
    \end{equation*}
\end{definition}

\subsubsection{Example}
Let \GG be the graph given in fig. \ref{fig:exlowlink}. The order of traversal of the graph is given by the value \textit{num} for each node of \GG. The \textit{lowlink} value is also displayed.

\begin{figure}[!h]
    \ctikzfig{lowlink}
    \caption{A DFS was performed through \GG from $x_1$ and next to each node is represented the couple of value (\textit{num}, \textit{lowlink})\label{fig:exlowlink}}
\end{figure}

Now, backtracking edges can be highlighted w.r.t. the order of traversal. In fig. \ref{fig:exlowlink2}, they are represented as red dashed arrows.\\
Knowing the backtracking edges, all \textit{lowlink} values can be computed\footnote{In fact, they are refreshed during the DFS.}.\\
Let us take $x_8$ as an example: its \textit{lowlink} is equal to 2, which actually means that $x_6$\footnote{Because $\texttt{x6.num} = 2$} is its anchor -- or attachment node -- in their SCC, namely the green one. Indeed, $x_8$ is alone in its equivalence class\footnote{for the relation $\Rightarrow$}, and from all nodes linked by one of the backtracking edges of $x_8$, $x_6$ has the minimum value \textit{num}. Likewise, $x_3$ is its own attachment node in the green SCC since it is the first node visited when performing the DFS.

\begin{figure}[!h]
    \ctikzfig{lowlink2}
    \caption{Same graph as in fig. \ref{fig:exlowlink} whose backtracking edges have been represented with red dashed arrows and SCCs have been highlighted\label{fig:exlowlink2}}
\end{figure}

Then, SCCs can be easily found, namely $\{x_1\}$ and $\{x_2,x_3,x_4,x_5,x_6,x_7,x_8, x_9\}$, as shown in fig. \ref{fig:exlowlink2}.

\pagebreak
\section{Tarjan's algorithm}
Tarjan's algorithm is an efficient on-the-fly SCC computing algorithm \cite{tarjanMerz}. It basically perfoms a DFS while updating the \textit{num} and \textit{lowlink} values. All nodes are stored in a stack during the traversal until a backtracking edge is found. In this case, the \textit{lowlinks} are computed and all nodes are unstacked and saved in a SCC until a node verifying the equality between its \textit{num} and its \textit{lowlink} -- which has to occur -- is found. Then, the DFS goes on. The whole process is written in the following algorithm \ref{alg:tarjan}.\\
It can be shown that every node and edge are visited only once so the algorithm can achieve a linear complexity, \textit{i.e.} $\mathcal{O}(|\mathcal{V}|+|\mathcal{E}|)$.

\subsection{Description of Tarjan's algorithm}
\begin{algorithm}[H]\label{alg:tarjan}
    \SetAlgoLined
    \KwData{A graph \GG = (\VV, \EE)}
    \KwResult{A partition \texttt{SCCs} of \VV where each element of \texttt{SCCs} is a SCC of \GG}
    Initialize an empty stack \texttt{R}\;
    Initialize an empty set \texttt{SCCs}\;
    Let $\texttt{num} := 0$\;
    \ForAll{$v \in \mathcal{V}$}{
        \If{\texttt{v.num} is unefined}{
            SCC(v)\;
        }
    }
    \SetKwProg{Function}{function}{}{}
    \Function{SCC: $v \in \mathcal{V} \rightarrow \texttt{None}$}{
        \texttt{v.num = num}\;
        \texttt{v.lowlink = num}\;
        increment \texttt{num}\;
        Push $v$ in \texttt{R}\;
        \texttt{v.onStack = true}\;
        \ForAll{$w \in \text{POST}(v)$}{
            \If{\texttt{w.num} is undefined}{
                \texttt{v.lowlink} = $\min(\texttt{v.lowlink, w.lowlink})$\;
            }
            \ElseIf{\texttt{w.onStack}}{
                \texttt{v.lowlink} = $\min(\texttt{v.lowlink, w.num})$\;
            }
        }
        \If{\texttt{v.lowlink = v.num}}{
            Initialize an empty set \texttt{currentSCC}\;
            \Repeat{$\texttt{v.num} \neq \texttt{w.num}$}{
                Let $w := \texttt{R.pop()}$\;
                \texttt{w.onStack = false}\;
                $\texttt{currentSCC} = \texttt{currentSCC} \cup \{w\}$\;
            }
            $\texttt{SCCs} = \texttt{SCCs} \cup \texttt{currentSCC}$\;
        }
    }
    \caption{Tarjan's algorithm}
\end{algorithm}
\pagebreak

\section{A sequential set-based algorithm}
\subsection{Formalisation}
\begin{definition}[SCC mapping]
    In the following algorithm, the SCCs are progressively tracked in a collection of disjoint sets through a map $\mathcal{S} : \mathcal{V} \longrightarrow \mathcal{P}(\mathcal{V})$, where $\mathcal{P}(\mathcal{V})$ is the powerset of \VV, s.t. the following invariant is maintained:
    \begin{equation}\label{invariant}
        \forall v, w \in \mathcal{V}, w\in \mathcal{S}(v) \Longleftrightarrow \mathcal{S}(v) = \mathcal{S}(w)
    \end{equation}
\end{definition}

\begin{remark}
    In particular, $\forall v \in \mathcal{V}, v \in \mathcal{S}(v)$.
\end{remark}

\begin{definition}[SCC union]
    Let \textsc{Unite} be the function taking as parameters a map $\mathcal{S}$ as defined previously and two vertices $u$ and $v$ of $\mathcal{V}$ such that $\textsc{Unite}(\mathcal{S}, u, v)$ merges the two mapped sets $\mathcal{S}(u)$ and $\mathcal{S}(v)$ and maintains the invariant (\ref{invariant}) by updating the function $\mathcal{S}$.
\end{definition}
Let us give an example:\\
Let $\mathcal{V} = \{u,v,w\}$ such that there is the following mapping: $\mathcal{S}(u) = \{u\}$ and $\mathcal{S}(v) = \mathcal{S}(w) = \{v,w\}$.\\
Then, $\textsc{Unite}(\mathcal{S}, u, v) = \mathcal{S}(u) = \mathcal{S}(v) = \mathcal{S}(w) = \{u,v,w\}$.

\begin{definition}[Successors set for a node]
    Let $\mathcal{G} = (\mathcal{V}, \mathcal{E})$ and $v \in \mathcal{V}$. The set of successors of $v$ in \GG is \textsc{Post}($v$) such that:
    \begin{equation*}
        \forall w\in \textsc{Post}(v), (v,w)\in \mathcal{E}
    \end{equation*}
\end{definition}

\subsection{The algorithm}
See \cite{articleSCC} for the original paper.\\
\begin{algorithm}[H]\label{alg:seqsetbased}
    \SetAlgoLined
    \KwData{A graph \GG = (\VV, \EE), a starting node $v_0$\;}
    \KwResult{A partition \texttt{SCCs} of \VV where each element of \texttt{SCCs} is a maximal set of strongly connected components of \GG\;}
    Initialize an empty set \texttt{EXPLORED}\;
    Initialize an empty set \texttt{VISITED}\;
    Initialize an empty stack \texttt{R}\;
    setBased($v_0$)\;
    \SetKwProg{Function}{function}{}{}
    \Function{setBased: $v \in \mathcal{V} \rightarrow \texttt{None}$}{
        $\texttt{VISITED} := \texttt{VISITED} \cup \{v\}$\;
        \texttt{R.push($v$)}\;
        \ForEach{$w\in \texttt{POST(v)}$}{
            \If{$w\in \texttt{EXPLORED}$}{
                continue\;
            }
            \ElseIf{$w \notin \texttt{VISITED}$}{
                setBased($w$)\;
            }
            \Else{
                \While{$\mathcal{S}(v) \neq \mathcal{S}(w)$}{
                    $r := \texttt{R.pop()}$\;
                    $\texttt{UNITE}(\mathcal{S}, r, \texttt{R.top()})$\;
                }
            }
        }
        \If{$v = \texttt{R.top()}$}{
            \textbf{report SCC} $\mathcal{S}(v)$\;
            $\texttt{EXPLORED} := \texttt{EXPLORED} \cup \mathcal{S}(v)$\;
            \texttt{R.pop()}\;
        }
    }
    
    \caption{Sequential set-based SCC algorithm}
\end{algorithm}

\pagebreak

\subsection{Informal proof}
Note that this proof is said informal only because it is not formally automated. Both logical and mathematical arguments developped below are absolutely relevant.

\begin{lemma}(First invariant)\label{lemma:disjointness}
    \begin{equation*}
        \forall x, y \in \texttt{R}, x\neq y \implies \mathcal{S}(x) \cap \mathcal{S}(y) = \varnothing
    \end{equation*}
    Note the misuse of the set notation $x, y \in \texttt{R}$ which just means that $x$ and $y$ are in the stack \texttt{R}.
\end{lemma}

\begin{proof}
    Let $x \in \mathcal{V}$ be the following node to be visited during the execution of the algorithm \ref{alg:seqsetbased}: $x$ is pushed in \texttt{R}. Let $y \in \textsc{Post}(x)$. There are two cases:\\
    \begin{itemize}
        \item y has not been visited yet, \textit{i.e.} $y \notin \textsc{Visited}$. Thus, a DFS-like traversal is performed from $y$, so $y$ is pushed in \texttt{R} and $\mathcal{S}(y) = \{y\}$ because $y$ is alone in its equivalence class for the moment since it has not been visited yet.\\
        Therefore, $\mathcal{S}(x) \cap \mathcal{S}(y) = \varnothing$.

        \item y has already been visited, \textit{i.e.} $y \in \textsc{Visited}$. Then, $y$ was already pushed in \texttt{R} before $x$. Let $(x_i)_{1\leq i \leq n}$ be the first nodes of the stack s.t. $x_0 = x$ and $x_n = y$.\\
        In order to avoid writing $\texttt{R} = [\ldots, y, \ldots, x]$, let us define $\widetilde{R}$ the stack containing the first $n$ nodes in \texttt{R}, s.t. $\widetilde{R} = [y, \ldots, x] = [x_n, \ldots, x_0]$.\\
        Let us consider the worst case, \textit{i.e.} when
        \begin{equation*}
            \forall~1 \leq i \leq n,~\mathcal{S}(x_i) = \{x_i\}
        \end{equation*}
        So, the while loop has to go down to $y$ because all partial SCCs are disjoint. As the length of the stack \texttt{R} is bounded by $|\mathcal{V}|$, the algorithm terminates.\\
        $x_0$ is first unstacked and both $\mathcal{S}(x_0)$ and $\mathcal{S}(\texttt{R.top()}) = \mathcal{S}(x_1)$ are then united. The current state of $\mathcal{S}$ and $\widetilde{R}$ is:
        \begin{equation*}
            \left\{
                \begin{array}{l}
                    \mathcal{S} = \{\{x_0, x_1\}, \{x_2\}, \ldots, \{x_n\}, \ldots\}\\
                    \widetilde{R} = [x_n, \ldots, x_1]\\
                \end{array}
            \right.
        \end{equation*}
        Then, $x_1$ is unstacked and $\mathcal{S}(x_1)$ and $\mathcal{S}(x_2)$ are then united, so that:
        \begin{equation*}
            \left\{
                    \begin{array}{l}
                        \mathcal{S} = \{\{x_0, x_1, x_2\}, \{x_3\}, \ldots, \{x_n\}, \ldots\}\\
                        \widetilde{R} = [x_n, \ldots, x_2]\\
                    \end{array}
                \right.
        \end{equation*}
        Finally (by induction), $\mathcal{S} = \{x_0, \ldots, x_n\}$ and $\widetilde{R} = [y]$, \textit{i.e.} $\mathcal{S}(x)=\mathcal{S}(y)$. It is important to notice that $x=x_0, x_1, \ldots, x_{n-1}$ are no longer in the stack, so this operation kept the invariant true.
    \end{itemize}
\end{proof}

\begin{lemma}
    \begin{equation*}
        \biguplus_{v \in \texttt{R}} \mathcal{S}(v) = \textsc{Live} := \textsc{Visited} \setminus \textsc{Explored}
    \end{equation*}
\end{lemma}

\begin{proof}
    The disjointness of all on-stack partial SCCs is given by lemma \ref{lemma:disjointness}. Nodes from $\textsc{Visited} \setminus \textsc{Eexplored}$ are in \texttt{R} because they are being processed. So, $\textsc{Live} \subseteq \texttt{R}$.\\
    By L.6-7 of algorithm \ref{alg:seqsetbased}, $\textsc{Visited} \subseteq \texttt{R}$.\\
    L.9-10 ensure that no explored node is pushed in \texttt{R}.\\
    L.24-25 keep the invariant by unstacking explored nodes from \texttt{R}, so $\texttt{R} \cap \textsc{Explored} = \varnothing$. Thus, $\texttt{R} = \textsc{Visited} \setminus \textsc{Explored} = \textsc{Live}$.
\end{proof}

\begin{corollary}\label{cor:cor1}
    \begin{equation*}
        \forall v \in \textsc{Live}, \exists!~r \in \texttt{R} \cap \mathcal{S}(v), \mathcal{S}(v) = \mathcal{S}(r)
    \end{equation*}
\end{corollary}
\begin{proof}
    Let $v \in \textsc{Live} = \displaystyle{\biguplus_{v \in \texttt{R}} \mathcal{S}(v)}$. $v$ is in a unique partial SCC $\mathscr{S} := \mathcal{S}(v)$. Because of lemma \ref{lemma:disjointness}, there cannot exist $x \neq y \in \texttt{R}$ s.t. $\mathcal{S}(x) = \mathcal{S}(y) = \mathscr{S}$. Thus, there exists a unique $x \in \texttt{R}$ s.t. $\mathcal{S}(x) = \mathscr{S}$ (and $x\in \texttt{R} \cap \mathscr{S}$).
\end{proof}

\begin{corollary}\label{cor:cor2}
    \begin{equation*}
        \forall v \in \mathcal{V}, \forall w \in \textsc{Post}(v), w \in \textsc{Live} \implies \exists w' \in \texttt{R}, \mathcal{S}(w') = \mathcal{S}(w)
    \end{equation*}
\end{corollary}

\begin{proof}
    Holds because of corollary \ref{cor:cor1}.
\end{proof}

\begin{remark}
    In the algorithm \ref{alg:seqsetbased}, this property is held by L.16-18. These lines also illustrate how the algorithm "reads" the SCCs. Corollary \ref{cor:cor2} shows that when the mapped representatives of the top two nodes of \texttt{R} are united (until $\mathcal{S}(w') = \mathcal{S}(v) = \mathcal{S}(w)$ since $w'$ has a path to $v$), then all united components are in the same SCC.
\end{remark}

\begin{remark}\label{rem:proof}
    Because \texttt{R} only contains exactly one representative for each partial SCC (corollary \ref{cor:cor1}), after each step of the main loop -- \textit{i.e.} the DFS -- every partial SCC is actually maximal in the current set of visited nodes.
\end{remark}

\begin{theorem}
    The sequential algorithm \ref{alg:seqsetbased} is correct, \textit{i.e.} it returns a set of maximal SCCs.
\end{theorem}
\begin{proof}
    Holds by remark \ref{rem:proof}.
\end{proof}

\pagebreak

\subsection{Formal proof}
Since the informal proof seems to be consistant, the formal -- automated -- proof can be written in Isabelle (HOL) based on the basis of the reasonning developped above.

\subsubsection{Environment setup}
The first definitions should be the different structures used in the algorithm. In particular, a record containing all the sets needed and described in the pseudo-code of algorithm \ref{alg:seqsetbased} :

\isa{
    {\color{isa_blue}record} \generic{v} env =\\
    $~~~\mathcal{S}$ :: "\generic{v} $\Rightarrow$ \generic{v} set"\\
    $~~~$explored :: "\generic{v} set"\\
    $~~~$visited :: "\generic{v} set"\\
    $~~~$sccs :: "\generic{v} set set"\\
    $~~~$stack :: "\generic{v} list"\\
}

The following lines define a graph structure and some useful natural relations :

\isa{
    {\locale} graph =\\
    $~~~$\fixes{} {\color{isa_dark_blue} vertices} :: "\generic{v} set" \and{} {\color{isa_dark_blue} successors} :: "\generic{v} $\Rightarrow$ \generic{v} set"\\
    $~~~$\assumes{} vfin: "finite {\color{isa_dark_blue}vertices}"\\
    $~~~$\and{} sclosed: "$\forall {\text{{\color{isa_dark_green}x}}} \in$ {\color{isa_dark_blue}vertices}. {\color{isa_dark_blue}successors} {\color{isa_dark_green}x} $\subseteq$ {\color{isa_dark_blue}vertices}"\\
}
\isa{
    \abbreviation{} edge \where\\
    $~~~$"{\color{isa_dark_blue}edge} {\color{isa_dark_green}x y} $\equiv$ {\color{isa_dark_green}y} $\in$ {\color{isa_dark_blue}successors} {\color{isa_dark_green}x}"
}

\isa{
    \inductive{} reachable \where\\
    $~~~$reachable\_refl[iff]: "{\color{isa_dark_blue}reachable} {\color{isa_dark_green}x x}"\\
    $~{\text{|}}$ reachable\_succ[elim]: "$\ldb$edge {\color{isa_dark_green}x y};  {\color{isa_dark_blue}reachable} {\color{isa_dark_green}y z}$\rdb \Longrightarrow$ {\color{isa_dark_blue}reachable} {\color{isa_dark_green}x z}"\\
}

Those two relations are \texttt{edge}, which simply translates the property for two nodes of being linked by an edge and \texttt{reachable}, which is the binary relation $\Rightarrow^*$ defined in section \ref{sec:directedgraphs}.\\
In order to be able to use those relations in the proofs later, it is essential to prove a list of lemmas, namely all the different natural properties that Isabelle cannot deduce\footnote{That is an abuse of language. The idea is for example that for the moment, there is no formal link between \texttt{edge} and \texttt{reachable}. The goal is to formalize it so Isabelle is logically able to both use and simplify some results in the proofs.} from nothing\footnote{There is actually a theorem fetcher that is particularly useful to find a basic set of lemmas.}. For instance, the following lemmas are essential.

\isa{
\lm{} reachable\_edge: "edge {\color{isa_dark_blue}x y} $\Longrightarrow$ reachable {\color{isa_dark_blue}x y}"\\
$~~~~~${\color{isa_blue}by} auto\\
}
Mathematical writing: $\forall x, \forall y, x \Rightarrow y \Longrightarrow x \Rightarrow^* y$

\isa{
\lm{} succ\_reachable:\\
$~~~~~$\assumes{} "reachable {\color{isa_dark_blue}x y}" \and{} "edge {\color{isa_dark_blue}y z}"\\
$~~~~~$\shows "reachable {\color{isa_dark_blue}x z}"\\
$~~~~~${\color{isa_blue}using} assms {\color{isa_blue}by} induct auto\\
}
Mathematical writing: $\forall x, \forall y, \forall z, (x \Rightarrow^* y \wedge y \Rightarrow z) \Longrightarrow x \Rightarrow^* z$

\isa{
\lm{} reachable\_trans:\\
$~~~~~$\assumes{} y: "reachable \blue{x y}" \and{} z: "reachable \blue{y z}"\\
$~~~~~$\shows{} "reachable \blue{x z}"\\
$~~~~~${\color{isa_blue}using} assms {\color{isa_blue}by} induct auto\\
}
Mathematical writing: $\forall x, \forall y, \forall z, (x \Rightarrow^* y \wedge y \Rightarrow^* z) \Longrightarrow x \Rightarrow^* z$\\

As the formal proofs will enventually deal with strongly connected components, it is also essential to formally define SCCs. For the purpose of the proof, the property of being a SCC is called \texttt{sub\_scc} and being a \textit{maximal} SCC is called \texttt{is\_scc} :

\isa{
{\color{isa_blue}definition} is\_subscc \where\\
$~~~~~$"is\_subscc S $\equiv \forall$ x $\in$ S. $\forall$ y $\in$ S. reachable x y"\\
}
Mathematical writing: A set $S$ is a SCC if $\forall x \in S, \forall y \in S, x \Rightarrow^* y$

\isa{
{\color{isa_blue}definition} is\_scc \where\\
$~~~~~$"is\_scc S $\equiv$ S $\neq$ \{\} $\wedge$ is\_subscc S\\
$~~~~~\wedge$ ($\forall$ S'. S $\subseteq$ S' $\wedge$ is\_subscc S' $\longrightarrow$ S' = S)"\\
}
Mathematical writing: A non-empty SCC $S$ is maximal if for all SCC $S'$, $S \subseteq S' \Longrightarrow S'=S$\\

Once again, there are some lemmas to prove, such as telling Isabelle when an element can be added to a SCC, or that two vertices that are reachable from each other are in the same SCC, or that two SCCs having a common element are identical.

\subsubsection{Implementation of the algorithm}

Now that the environment is set up, the actual algorithm -- seen as a function -- can be implemented.\\
Since Isabelle does not support loops, the implementation will be split into two mutually recursive functions. The main function is called \texttt{dfs} and takes its name after the Depth First Search algorithm because the algorithm \ref{alg:seqsetbased} roughly consists in a deep traversal of a graph. The second function is called \texttt{dfss} and represents the \textit{while} loop of the algorithm \ref{alg:seqsetbased}. The two functions are mutually recursive because they recursively call each other. In particular, \texttt{dfss} will call either itself or \texttt{dfs}, depending on the case.

\isa{
    {\color{isa_blue}{function}} dfs :: "\generic{v} $\Rightarrow$ \generic{v} env $\Rightarrow$ \generic{v} env" \and{}\\
    $~~~~~~~~~~$dfss:: "\generic{v} $\Rightarrow$ \generic{v} set $\Rightarrow$ \generic{v} env $\Rightarrow$ \generic{v} env" \where\\
    "{\color{isa_dark_blue}dfs} {\color{isa_dark_green}v e} =\\
    $~~~~~$({\color{isa_blue}{let}} {\color{isa_dark_green}e1} = {\color{isa_dark_green}e}\env{visited := visited e $\cup$ \{{\color{isa_dark_green}v}\}, stack := ({\color{isa_dark_green}v} \# stack {\color{isa_dark_green}e})};\\
    $~~~~~~~~~~${\color{isa_dark_green}e'} = {\color{isa_dark_blue}dfss} {\color{isa_dark_green}v} (successors {\color{isa_dark_green}v}) {\color{isa_dark_green}e1}\\
    $~~~~~${\color{isa_blue}{in if}} {\color{isa_dark_green}v} = hd(stack {\color{isa_dark_green}e'})\\
    $~~~~~~~~~~${\color{isa_blue}{then}} {\color{isa_dark_green}e'}\env{sccs:=sccs {\color{isa_dark_green}e'} $\cup$ {$\mathcal{S}$ {\color{isa_dark_green}e' v}}, explored:=explored {\color{isa_dark_green}e'} $\cup$ ($\mathcal{S}$ {\color{isa_dark_green}e' v}), stack:=tl(stack {\color{isa_dark_green}e'})}\\
    $~~~~~~~~~~${\color{isa_blue}else} {\color{isa_dark_green}e'})"\\
    | "{\color{isa_dark_blue}dfss} {\color{isa_dark_green}v vs e} =\\
    $~~~~~$({\color{isa_blue}if} {\color{isa_dark_green}vs} = \{\} {\color{isa_blue}then} {\color{isa_dark_green}e}\\
    $~~~~~${\color{isa_blue}else} ({\color{isa_blue}let} {\color{isa_dark_green}w} = SOME {\color{isa_dark_green}x}. {\color{isa_dark_green}x} $\in$ {\color{isa_dark_green}vs}\\
    $~~~~~~~~~~${\color{isa_blue}in} ({\color{isa_blue}let} {\color{isa_dark_green}e'} = ({\color{isa_blue}if} {\color{isa_dark_green}w} $\in$ explored {\color{isa_dark_green}e} {\color{isa_blue}then} {\color{isa_dark_green}e}\\
    $~~~~~~~~~~~~~~~~~~~${\color{isa_blue}else if} {\color{isa_dark_green}w} $\notin$ visited {\color{isa_dark_green}e} {\color{isa_blue}then} {\color{isa_dark_blue}dfs} {\color{isa_dark_green}w e}\\
    $~~~~~~~~~~~~~~~~~~~${\color{isa_blue}else} unite {\color{isa_dark_green}v w e})\\
    $~~~~~~~~~~~~~~${\color{isa_blue}in} {\color{isa_dark_blue}dfss} {\color{isa_dark_green}v} ({\color{isa_dark_green}v} - \{{\color{isa_dark_green}w}\}) {\color{isa_dark_green}e'})))"\\
    $~~~${\color{isa_blue}by} pat\_completeness (force+)\\
}

The two last keywords require explanations as well : \texttt{pat\_completeness} stands for \textit{pattern completeness} and ensures that there is no missing patterns. The keyword \texttt{force} is used\footnote{Here, \texttt{auto} cannot terminate because of the mutual recursion.} to help Isabelle know -- by proving it -- that both \texttt{dfs} and \texttt{dfss} are actually functions and that those functions are well defined with respect to the usual logical and mathematical meaning.

\pagebreak

\begin{thebibliography}{99}

\bibitem{tarjanMerz} R. Chen, C. Cohen, J.-J. Lévy, S. Merz, L. Théry, \emph{Formal Proofs of Tarjan’s Strongly Connected 2 Components Algorithm in Why3, Coq and Isabelle}, 2019

\bibitem{thesisBloemen} V. Bloemen, A. Laarman, J. van de Pol, \emph{Multi-Core On-The-Fly SCC Decomposition}, 2016

\bibitem{articleSCC} V. Bloemen, \emph{Strong Connectivity and Shortest Paths for Checking Models}, 2019

\end{thebibliography}

\end{document}

