\documentclass{beamer}
\usepackage{graphicx}
\usepackage{amsmath, amsthm, amsfonts, amssymb, mathrsfs}
\usepackage{textcomp} % straigth apos
\usepackage{tikz}
\usepackage{verbatim}
\usepackage{tikzit}
\usepackage{listings}
\usepackage[ruled,vlined, linesnumbered]{algorithm2e}
\usepackage{algorithmic,float}


\input{graphs.tikzstyles}

% Graph notations
\def\NN{$\mathcal{N}~$}
\def\GG{$\mathcal{G}~$}
\def\VV{$\mathcal{V}~$}
\def\EE{$\mathcal{E}~$}


% Colors definition
\definecolor{isa_red}{RGB}{255, 58, 71}
\definecolor{isa_blue}{RGB}{0, 103, 158}
\definecolor{isa_green}{RGB}{0, 157, 97}
\definecolor{isa_dark_green}{RGB}{0,131, 0}
\definecolor{isa_purple}{RGB}{174, 5, 238}
\definecolor{isa_dark_blue}{RGB}{26, 0, 253}

% Isabelle keywords
\newcommand{\apply}{{\color{isa_red}{apply}}}
\newcommand{\done}{{\color{isa_red}{done}}}
\newcommand{\datatype}{{\color{isa_blue}{datatype}}}
\newcommand{\thm}{{\color{isa_blue}{theorem}}}
\newcommand{\lm}{{\color{isa_blue}{lemma}}}
\newcommand{\fun}{{\color{isa_blue}{fun}}}
\newcommand{\where}{{\color{isa_green}{where}}}
\newcommand{\generic}[1]{{\color{isa_purple}{\textquotesingle#1}}}
\newcommand{\isa}[1]{\texttt{#1}}
\newcommand{\blue}[1]{{\color{isa_dark_blue}{#1}}}
\newcommand{\green}[1]{{\color{isa_dark_green}{#1}}}


\theoremstyle{definition}
\newtheorem*{isabelle}{}

\setbeamercovered{invisible}

\setbeamertemplate{theorems}[numbered]
\setbeamertemplate{lemma}[numbered]
\newtheorem{remark}{Remark}

\usetheme{Madrid}
\useoutertheme{tree} % Alternatively: miniframes, infolines, split
\useinnertheme{circles}

\definecolor{lightbrown}{RGB}{220, 147, 91}

\usecolortheme[named=lightbrown]{structure}

\title[Midterm presentation of the research course]{Verification in HOL of an algorithm for computing SCCs}
%% sm: not really convinced by the title -- FM in HOL sounds redundant to me
%% also are there really several algorithms?
%% maybe "Verification in HOL of an algorithm for computing SCCs" ?
\date{January 14, 2022}
\author[V. Trélat]{Vincent Trélat}
\institute[Mines Nancy]{\normalsize{École Nationale Supérieure des Mines de Nancy\\Département Informatique}}

\begin{document}

\begin{frame}
  \begin{figure}[t]
    \centering
    \includegraphics[height=30pt]{img/logoartem.png}
    \hspace{1cm}
    \includegraphics[height=32pt]{img/logoloria.jpg}
    \hspace{1cm}
    \includegraphics[height=30pt]{img/logoUL.png}
  \end{figure}
  \titlepage
\end{frame}

\section{Introduction}
\begin{frame}
  \tableofcontents
\end{frame}

\subsection{Definition}

\begin{frame}
  \only<1>{
    \ctikzfig{slides_sccex1}
  }
  \only<2-3>{
    \ctikzfig{slides_sccex2}
  }
  \only<4->{
    \ctikzfig{slides_sccex3}
  }
  \only<1-4>{
    \uncover<3->{
      \begin{definition}
        Let $\mathcal{G} := (\mathcal{V}, \mathcal{E})$ be a \blue{directed graph} and $\mathcal{C} \subseteq \mathcal{V}$.
        $\mathcal{C}$ is a SCC of $\mathcal{G}$ if:
        \begin{equation*}
          \forall x, y \in \mathcal{C}, (x \Rightarrow y) \wedge (y \Rightarrow x)
        \end{equation*}
      \end{definition}
      }
  }
\end{frame}

\subsection{Motivation}
\begin{frame}
%% sm: This slide introduces three items whose relationship is unclear.
%% What is being motivated here? Model checking presumably never appears
%% again in the talk. I think I'd start with a figure of a graph and its
%% SCCs, an informal description of what an SCC is, two examples of
%% where SCCs play a role, and then say that there exist efficient algorithms
%% for computing SCCs, but that they are quite tricky, so that formal
%% verification of their correctness is worthwhile. The whole in 2 slides.
\onslide<1->{
  \ctikzfig{biggraph}
}
\only<1>{
  \centering
  Motivation
}
\onslide<2->{
  \begin{itemize}
    \item Networks: connection and data sharing
    \item Model checking: counter-examples finding
  \end{itemize}
}
\vfill
\onslide<3->{
  Efficient algorithms (ex: Tarjan)
  \begin{itemize}
    \item Formal verification of correctness is worthwhile
    \item Parallelization is another challenge
  \end{itemize}
}
\end{frame}

\begin{frame}
%% sm: perhaps say why HOL is convenient for abstract modeling and proof?
  \begin{center}
    Isabelle / HOL
  \end{center}
  \begin{itemize}
    \item Generic proof assistant
    \vfill
    \item Formalisation of mathematical proofs
    \vfill
    \item Higher-Order Logic theorem proving environment
    \vfill
    \item Powerful proof tools and language (Isar) % understandable by both the user and the machine
    \vfill
    \item Mutual induction, recursion and datatypes, complex pattern matching
  \end{itemize}
\end{frame}

\subsection[Example proof]{Example of the proof process}

\begin{frame}
  \centering
  Example
  \vfill
  Simple proofs on a basic data structure
\end{frame}

\begin{frame}
  \begin{isabelle}[Type definition]
    \isa{
      \datatype{} \generic{a} list = Empty | Cons \generic{a} "\generic{a} list"
    }
  \end{isabelle}
  \begin{itemize}
    \item Generic / polymorphic and static type
    \item Implicit constructor definition
    \item Recursive structure giving an induction principle for that type
  \end{itemize}
  %% sm: mention that a recursive data type gives rise to an induction
  %% principle for that type?
\end{frame}

\begin{frame}
  \begin{isabelle}[Function definition]
    \isa{
      \fun{} concat :: "\generic{a} list $\Rightarrow$ \generic{a} list $\Rightarrow$ \generic{a} list" \where\\
      ~~~"\blue{concat} Empty \green{xs} = \green{xs}"\\
      ~| "\blue{concat} (Cons \green{x xs}) \green{ys} = Cons \green{x} (\blue{concat} \green{xs ys})"
    }
  \end{isabelle}
  \begin{isabelle}
    \isa{
      \fun{} rev :: "\generic{a} list $\Rightarrow$ \generic{a} list" \where\\
      ~~~"\blue{rev} Empty = Empty"\\
      ~| "\blue{rev} (Cons \green{x xs}) = concat (\blue{rev} \green{xs}) (Cons \green{x} Empty)"
    }
  \end{isabelle}
\end{frame}

\begin{frame}
  \begin{isabelle}[Theorem statement]
    \onslide<1->{
      \isa{
        \thm{} rev\_rev [simp]: "rev (rev \blue{x}) = \blue{x}"\\
      }
    }
    \onslide<2->{
      ~~~\apply{} (induction \blue{x})\\
      ~~~\apply{} auto\\
    }
    \end{isabelle}
    \onslide<3->{
      \begin{isabelle}[Subgoal]
        \isa{
          $\bigwedge$ \green{x1 x}.\\
          ~~~rev (rev \green{x}) = \green{x} $\Longrightarrow$\\
          ~~~rev (concat (rev \green{x}) (Cons \green{x1} Empty) = Cons \green{x1 x}
        }
      \end{isabelle}
    }
\end{frame}

\begin{frame}
  \onslide<1->{
  \begin{isabelle}[Adding a first lemma]
    \isa{
      \lm{} rev\_concat [simp]:\\"rev (concat \blue{xs ys}) = concat (rev \blue{ys}) (rev \blue{xs})"\\
%% sm: bad layout, break line after colon, renaming to rev should again help
      ~~~\apply{} (induction \blue{xs})\\
      ~~~\apply{} auto
    }
  \end{isabelle}
  }
  \onslide<2->{
  \begin{isabelle}[Subgoals]
    \footnotesize{
    \isa{
      1. rev \blue{ys} = concat (rev \blue{ys}) Empty\\
      ~2. $\bigwedge$ \green{x1 xs}.\\
          ~~~rev (concat \green{xs} \blue{ys}) = concat (rev \blue{ys}) (rev \green{xs}) $\Longrightarrow$\\
          ~~~rev (concat (Cons \green{x1 xs}) \blue{ys}) = concat (rev \blue{ys}) (rev (Cons \green{x1 xs}))
    }
    }
  \end{isabelle}
  }
\end{frame}

\begin{frame}
  \begin{isabelle}[Adding a second lemma]
    \isa{
      \lm{} concat\_empty [simp]: "concat \blue{xs} Empty = xs"\\
      ~~~\apply{} (induction \blue{xs})\\
      ~~~\apply{} auto
    }
  \end{isabelle}
  \begin{isabelle}[Adding a third lemma: associative property]
    \isa{
      \lm{} concat\_assoc [simp]: "concat (concat \blue{xs ys}) \blue{zs} = concat \blue{xs} (concat \blue{ys zs})"\\
      ~~~\apply{} (induction \blue{xs})\\
      ~~~\apply{} auto
    }
  \end{isabelle}
\end{frame}

\begin{frame}
  \begin{isabelle}
    \isa{
      \thm{} rev\_rev [simp]: "rev (rev \blue{x}) = \blue{x}"\\
      ~~~\apply{} (induction \blue{x})\\
      ~~~\apply{} auto\\
    }
  \end{isabelle}
  No subgoals!
\end{frame}

\section[Correctness]{Correctness of the SCC algorithm}
\begin{frame}
  \centering
  A sequential set-based SCC algorithm
\end{frame}

\subsection{Description of the algorithm}

\setbeamercovered{transparent}
\begin{frame}[fragile]
%% sm: Instead of starting a slide with a definition, I'd first show the
%% picture. The definition could perhaps be shown directly in Isabelle
%% notation (on a later slide)?
\onslide<1->{
\fboxsep=0pt
\noindent{%
\begin{minipage}[c]{0.48\linewidth}
  \setlength{\interspacetitleruled}{0pt}%
  \setlength{\algotitleheightrule}{0pt}%
  \begin{algorithm}[H]
    \tiny
    \uncover<1, 12>{
    \KwData{A graph \GG = (\VV, \EE), a starting node $v_0$\;}
    Initialize an empty set \texttt{DEAD}\;
    Initialize an empty set \texttt{VISITED}\;
    Initialize an empty stack \texttt{R}\;
    setBased($v_0$)\;
    }
    \SetKwProg{Function}{function}{}{}
    \uncover<2->{
    \Function{setBased: $v \in \mathcal{V} \rightarrow \texttt{None}$}{
      $\texttt{VISITED} := \texttt{VISITED} \cup \{v\}$\;
      \texttt{R.push($v$)}\;
        \ForEach{$w\in \texttt{POST(v)}$}{
            \If{$w\in \texttt{DEAD}$}{
                continue\;
            }
            \ElseIf{$w \notin \texttt{VISITED}$}{
                setBased($w$)\;
            }
            \Else{
                \While{$\mathcal{S}(v) \neq \mathcal{S}(w)$}{
                    $r := \texttt{R.pop()}$\;
                    $\texttt{UNITE}(\mathcal{S}, r, \texttt{R.top()})$\;
                }
            }
        }
        \If{$v = \texttt{R.top()}$}{
            \textbf{report SCC} $\mathcal{S}(v)$\;
            $\texttt{DEAD} := \texttt{DEAD} \cup \mathcal{S}(v)$\;
            \texttt{R.pop()}\;
        }
    }
    }
  \end{algorithm}
\end{minipage}}%
}
\hfill%
{%
\begin{minipage}[c]{0.48\linewidth}
\only<+>{
  \ctikzfig{slides_seqalg1}
}
\only<+>{
  \ctikzfig{slides_seqalg2}
}
\only<+>{
  \ctikzfig{slides_seqalg3}
}
\only<+>{
  \ctikzfig{slides_seqalg4}
}
\only<+>{
  \ctikzfig{slides_seqalg5}
}
\only<+>{
  \ctikzfig{slides_seqalg6}
}
\only<+>{
  \ctikzfig{slides_seqalg7}
}
\only<+>{
  \ctikzfig{slides_seqalg8}
}
\only<+>{
  \ctikzfig{slides_seqalg9}
}
\only<+>{
  \ctikzfig{slides_seqalg10}
}
\only<+>{
  \ctikzfig{slides_seqalg11}
}
\only<+>{
  \ctikzfig{slides_seqalg12}
}
\end{minipage}
}
\end{frame}

\begin{frame}
  

\end{frame}

\end{document}